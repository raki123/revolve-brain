diff --git a/cpp/CMakeLists.txt b/cpp/CMakeLists.txt
index 2557f7c..6400d92 100644
--- a/cpp/CMakeLists.txt
+++ b/cpp/CMakeLists.txt
@@ -52,7 +52,8 @@ file(GLOB_RECURSE BRAIN_SRCS
         brain/supg/supgneuron.cpp
         brain/supg/supggenomemanager.cpp
         neat/asyncneat.cpp
-        neat/neatevaluation.cpp)
+        neat/neatevaluation.cpp
+        brain/basic_neat_brain.cpp)
 
 # Compiling ####################################################################
 add_library(revolve-brain-static STATIC ${BRAIN_SRCS})
diff --git a/cpp/brain/basic_neat_brain.cpp b/cpp/brain/basic_neat_brain.cpp
new file mode 100644
index 0000000..069c608
--- /dev/null
+++ b/cpp/brain/basic_neat_brain.cpp
@@ -0,0 +1,87 @@
+#include "basic_neat_brain.h"
+#include "neat/asyncneat.h"
+#include <sstream>
+#include <stdexcept>
+#include <limits>
+#include <iomanip>
+#include <string>
+#include <ctime>
+
+using namespace revolve::brain;
+
+
+BasicBrain::BasicBrain(EvaluatorPtr evaluator,
+                     const std::vector< ActuatorPtr >& actuators,
+                     const std::vector< SensorPtr >& sensors)
+  : evaluator(evaluator)
+  , start_eval_time(std::numeric_limits< double >::lowest())
+  , generation_counter(0)
+
+{
+    unsigned int p = 0;
+    std::cout<<"sensor->sensorId()"<<std::endl;
+    for (auto sensor : sensors) {
+        std::cout << "sensor: " << sensor->sensorId() << "(inputs: " << sensor->inputs() << ")" << std::endl;
+        p += sensor->inputs();
+    }
+    std::cout<<"END sensor->sensorId()"<<std::endl;
+    n_inputs = p;
+
+    p = 0;
+    for (auto actuator : actuators) {
+        p += actuator->outputs();
+    }
+    n_outputs = p;
+
+    this->init_async_neat();
+}
+
+void BasicBrain::init_async_neat() {
+    AsyncNeat::Init();
+    unsigned long populationSize = 10;
+    NEAT::GeneticSearchType geneticSearchType = NEAT::GeneticSearchType::PHASED;
+
+
+    AsyncNeat::SetPopulationSize(populationSize); // 10 - 25 - 50 - 75 - 100 - 1000
+    AsyncNeat::SetSearchType(geneticSearchType);
+    std::unique_ptr< AsyncNeat > neat(new AsyncNeat(
+        n_inputs,
+        n_outputs,
+        std::time(0)
+    ));
+    this->neat = std::move(neat);
+}
+
+
+void BasicBrain::update(const std::vector< ActuatorPtr >& actuators,
+                       const std::vector< SensorPtr >& sensors,
+                       double t, double step)
+{
+    this->update<std::vector<ActuatorPtr>, std::vector<SensorPtr>>(actuators, sensors, t, step);
+}
+
+double BasicBrain::getFitness()
+{
+    //Calculate fitness for current policy
+    double fitness = evaluator->fitness();
+    std::cout << "Evaluating gait, fitness = " << fitness << std::endl;
+    return fitness;
+}
+
+void BasicBrain::nextBrain()
+{
+    bool init_supgs;
+    if (!current_evalaution) {
+        // first evaluation
+        init_supgs = true;
+    } else {
+        // normal change of evaluation
+        init_supgs = false;
+        current_evalaution->finish(getFitness());
+    }
+
+    current_evalaution = neat->getEvaluation();
+    cppn = reinterpret_cast< NEAT::CpuNetwork* > (
+        current_evalaution->getOrganism()->net.get()
+    );
+}
diff --git a/cpp/brain/basic_neat_brain.h b/cpp/brain/basic_neat_brain.h
new file mode 100644
index 0000000..58827cc
--- /dev/null
+++ b/cpp/brain/basic_neat_brain.h
@@ -0,0 +1,139 @@
+#ifndef REVOLVE_BRAIN_BASIC_NEAT_BRAIN_H
+#define REVOLVE_BRAIN_BASIC_NEAT_BRAIN_H
+
+#include "brain.h"
+#include "neat/asyncneat.h"
+#include "evaluator.h"
+#include "neat/accneat/src/network/cpu/cpunetwork.h"
+
+#include <vector>
+#include <memory>
+#include <iostream>
+
+namespace revolve {
+namespace brain {
+
+class BasicBrain : public Brain
+{
+//METHODS
+public:
+    BasicBrain(EvaluatorPtr evaluator,
+              const std::vector< ActuatorPtr >& actuators,
+              const std::vector< SensorPtr >& sensors);
+    ~BasicBrain() {}
+
+    virtual void update(const std::vector< ActuatorPtr >& actuators,
+                        const std::vector< SensorPtr >& sensors,
+                        double t, double step) override;
+
+protected:
+
+    template<typename ActuatorContainer, typename SensorContainer>
+    void update(const ActuatorContainer &actuators,
+                const SensorContainer &sensors,
+                double t,
+                double step)
+    {
+
+        // Evaluate policy on certain time limit
+        if ((t-start_eval_time) > BasicBrain::FREQUENCY_RATE) {
+
+            // check if to stop the experiment. Negative value for MAX_EVALUATIONS will never stop the experiment
+            if (BasicBrain::MAX_EVALUATIONS > 0 && generation_counter > BasicBrain::MAX_EVALUATIONS) {
+                std::cout << "Max Evaluations (" << BasicBrain::MAX_EVALUATIONS << ") reached. stopping now." << std::endl;
+                std::exit(0);
+            }
+            generation_counter++;
+            std::cout << "################# EVALUATING NEW BRAIN !!!!!!!!!!!!!!!!!!!!!!!!! (generation " << generation_counter << " )" << std::endl;
+            this->nextBrain();
+            start_eval_time = t;
+            evaluator->start();
+        }
+
+        assert(n_outputs == actuators.size());
+
+        // Read sensor data and feed the neural network
+        std::vector<double> inputs(n_inputs,0);
+        unsigned int p = 0;
+        for (auto sensor : sensors) {
+            sensor->read(&inputs[p]);
+            p += sensor->inputs();
+        }
+        assert(p == n_inputs);
+	std::vector<float> floatIns(n_inputs,0);
+	for(unsigned int i = 0; i < n_inputs; i++) {
+	    floatIns[i] = inputs[i];
+// 	    std::cout << inputs[i] << " " << floatIns[i] << " ";
+	}	
+// 	std::cout << n_inputs << " " << n_outputs;
+	NEAT::NetDims dims = cppn->get_dims();
+	std::cout << dims.nlinks << " " << dims.nnodes.all;
+// 	std::cout << std::endl;
+	cppn->set_activations(floatIns);
+	
+
+        // Activate network and save results
+	cppn->activate(1);
+	std::vector<float> outputvect(n_outputs, 0);
+        cppn->get_activations(outputvect).data();
+	std::vector<double> outputDouble(n_outputs,0);
+	for(unsigned int i = 0; i < n_outputs; i++) {
+	    outputDouble[i] = outputvect[i];
+// 	    std::cout << outputDouble[i] << " " << outputvect[i] << " ";
+	}	
+// 	std::cout << std::endl;
+	double *outputs = outputDouble.data();
+        // send signals to actuators
+        p = 0;
+        for (auto actuator: actuators) {
+            actuator->update(&outputs[p], step);
+            p += actuator->outputs();
+        }
+        assert(p == n_outputs);
+    }
+
+    void init_async_neat();
+
+private:
+    double getFitness();
+    void nextBrain();
+// DATA
+protected:
+    unsigned int n_inputs, n_outputs;
+
+private:
+    std::unique_ptr<AsyncNeat> neat;
+    EvaluatorPtr evaluator;
+    double start_eval_time;
+    unsigned int generation_counter;
+    std::shared_ptr< NeatEvaluation > current_evalaution;
+    NEAT::CpuNetwork *cppn;
+
+    /**
+     * Number of evaluations before the program quits. Usefull to do long run
+     * tests. If negative (default value), it will never stop.
+     *
+     * Takes value from env variable SUPG_MAX_EVALUATIONS.
+     * Default value -1
+     */
+    const long MAX_EVALUATIONS= -1; // max number of evaluations
+    /**
+     * How long should an evaluation lasts (in seconds)
+     *
+     * Takes value from env variable SUPG_FREQUENCY_RATE
+     * Default value 30 seconds
+     */
+    const double FREQUENCY_RATE= 30; // seconds
+    /**
+     * How long should the supg timer cicle be (in seconds)
+     *
+     * Takes value from env variable SUPG_CYCLE_LENGTH
+     * Default value 5 seconds
+     */
+    const double CYCLE_LENGTH = 5; // seconds
+};
+
+}
+}
+
+#endif // REVOLVE_BRAIN_BASIC_NEAT_BRAIN_H
diff --git a/cpp/brain/innovgenome/innovation.cpp b/cpp/brain/innovgenome/innovation.cpp
new file mode 100644
index 0000000..ed4e773
--- /dev/null
+++ b/cpp/brain/innovgenome/innovation.cpp
@@ -0,0 +1,198 @@
+    /*
+ Copyright 2001 The University of Texas at Austin
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+
+#include "innovation.h"
+#include "util/util.h"
+
+#ifdef WITH_OPENMP
+#include <omp.h>
+#endif
+
+#include <algorithm>
+#include <vector>
+
+using namespace NEAT;
+
+static int cmp(const InnovationId &x, const InnovationId &y) {
+#define __cmp(val)                              \
+    if(x.val < y.val) {return -1;}              \
+    else if(x.val > y.val) {return 1;}
+
+    __cmp(innovation_type);
+    __cmp(node_in_id);
+    __cmp(node_out_id);
+
+    switch(x.innovation_type) {
+    case NEWNODE:
+        __cmp(old_innov_num);
+        return 0;
+    case NEWLINK:
+        __cmp(recur_flag);
+        return 0;
+    default:
+        trap("invalid innovation_type");
+    }
+
+#undef __cmp
+}
+
+InnovationId::InnovationId(int nin,
+                           int nout,
+                           int oldinnov)
+    : innovation_type(NEWNODE)
+    , node_in_id(nin)
+    , node_out_id(nout)
+    , old_innov_num(oldinnov)
+    , recur_flag(false) { // unused
+}
+
+InnovationId::InnovationId(int nin,
+                           int nout,
+                           bool recur)
+    : innovation_type(NEWLINK)
+    , node_in_id(nin)
+    , node_out_id(nout)
+    , old_innov_num(-1) // unused
+    , recur_flag(recur) {
+}
+
+bool InnovationId::operator<(const InnovationId &other) const {
+    return ::cmp(*this, other) < 0;
+}
+
+bool InnovationId::operator==(const InnovationId &other) const {
+    return ::cmp(*this, other) == 0;
+}
+
+InnovationParms::InnovationParms()
+    : new_weight(-1)
+    , new_trait_id(-1) {
+}
+
+InnovationParms::InnovationParms(real_t w,
+                                 int t)
+    : new_weight(w)
+    , new_trait_id(t) {
+}
+
+IndividualInnovation::IndividualInnovation(int population_index_,
+                                           InnovationId id_,
+                                           InnovationParms parms_,
+                                           ApplyFunc apply_)
+    : population_index(population_index_)
+    , id(id_)
+    , parms(parms_) {
+    apply = apply_;
+}
+
+// Link
+Innovation::Innovation(InnovationId id_,
+                       InnovationParms parms_,
+                       int innovation_num1_)
+    : id(id_)
+    , parms(parms_)
+    , innovation_num1(innovation_num1_) {
+}
+
+// Node
+Innovation::Innovation(InnovationId id_,
+                       InnovationParms parms_,
+                       int innovation_num1_,
+                       int innovation_num2_,
+                       int newnode_id_)
+    : id(id_)
+    , parms(parms_)
+    , innovation_num1(innovation_num1_)
+    , innovation_num2(innovation_num2_)
+    , newnode_id(newnode_id_) {
+}
+
+static bool cmp_ind(const IndividualInnovation &x, const IndividualInnovation &y) {
+    return x.population_index < y.population_index;
+};
+
+void PopulationInnovations::init(int node_id, int innov_num) {
+    cur_node_id = node_id;
+    cur_innov_num = innov_num;
+
+#ifdef WITH_OPENMP
+    innovations.resize( omp_get_max_threads() );
+#else
+    innovations.resize( 1 );
+#endif
+}
+
+void PopulationInnovations::add(const IndividualInnovation &innov) {
+#ifdef WITH_OPENMP
+    innovations[omp_get_thread_num()].push_back(innov);
+#else
+    innovations[0].push_back(innov);
+#endif
+}
+
+void PopulationInnovations::apply() {
+    id2inds.clear();
+    for(std::vector<IndividualInnovation> &inds: innovations) {
+        for(auto &ind: inds) {
+            id2inds[ind.id].push_back(ind);
+        }
+        inds.clear();
+    }
+
+    std::vector<IndividualInnovation> masters;
+    for(auto &kv: id2inds) {
+        auto &inds = kv.second;
+
+        std::sort(inds.begin(), inds.end(), cmp_ind);
+
+        auto &master = inds.front();
+        masters.push_back(master);
+    }
+
+    std::sort(masters.begin(), masters.end(), cmp_ind);
+
+    for(auto &master: masters) {
+        auto &inds = id2inds[master.id];
+
+        Innovation *innov;
+
+        switch(master.id.innovation_type) {
+        case NEWNODE: {
+            innov = new Innovation(master.id,
+                                   master.parms,
+                                   cur_innov_num,
+                                   cur_innov_num + 1,
+                                   cur_node_id);
+            cur_innov_num += 2;
+            cur_node_id += 1;
+        } break;
+        case NEWLINK: {
+            innov = new Innovation(master.id,
+                                   master.parms,
+                                   cur_innov_num);
+            cur_innov_num += 1;
+        } break;
+        default:
+            trap("here");
+        }
+
+        for(IndividualInnovation &ind: inds) {
+            ind.apply(innov);
+        }
+
+        delete innov;
+    }
+}
diff --git a/cpp/brain/innovgenome/innovation.h b/cpp/brain/innovgenome/innovation.h
new file mode 100644
index 0000000..d59bf01
--- /dev/null
+++ b/cpp/brain/innovgenome/innovation.h
@@ -0,0 +1,110 @@
+/*
+  Copyright 2001 The University of Texas at Austin
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+*/
+#ifndef _INNOVATION_H_
+#define _INNOVATION_H_
+
+#include "neat.h"
+#include <functional>
+#include <map>
+
+namespace NEAT {
+
+    enum innovtype {
+        NEWNODE = 0,
+        NEWLINK = 1
+    };
+
+    class InnovationId {
+    public:
+        innovtype innovation_type;
+        int node_in_id;
+        int node_out_id;
+        int old_innov_num;
+        bool recur_flag;
+
+        // Node
+        InnovationId(int nin, int nout, int oldinnov);
+        // Link
+        InnovationId(int nin, int nout, bool recur);
+
+        bool operator<(const InnovationId &other) const;
+        bool operator==(const InnovationId &other) const;
+    };
+
+    class InnovationParms {
+    public:
+        real_t new_weight;
+        int new_trait_id;
+
+        InnovationParms();
+        InnovationParms(real_t w, int t);
+    };
+
+    class IndividualInnovation {
+    public:
+        typedef std::function<void (const class Innovation *innov)> ApplyFunc;
+
+        int population_index;
+        InnovationId id;
+        InnovationParms parms;
+        ApplyFunc apply;
+
+        IndividualInnovation(int population_index_,
+                             InnovationId id_,
+                             InnovationParms parms_,
+                             ApplyFunc apply_);
+    };
+
+    typedef std::function<void (InnovationId id,
+                                InnovationParms parms,
+                                IndividualInnovation::ApplyFunc func )> CreateInnovationFunc;
+
+    class Innovation {
+    public:
+        InnovationId id;
+        InnovationParms parms;
+
+        int innovation_num1;  //The number assigned to the innovation
+        int innovation_num2;  // If this is a new node innovation, then there are 2 innovations (links) added for the new node
+        int newnode_id;  // If a new node was created, this is its node_id
+
+        // Link
+        Innovation(InnovationId id_,
+                   InnovationParms parms_,
+                   int innovation_num1_);
+
+        // Node
+        Innovation(InnovationId id_,
+                   InnovationParms parms_,
+                   int innovation_num1_,
+                   int innovation_num2_,
+                   int newnode_id_);
+    };
+
+    class PopulationInnovations {
+        std::vector<std::vector<IndividualInnovation>> innovations;  // For holding the genetic innovations of the newest generation
+        std::map<InnovationId, std::vector<IndividualInnovation>> id2inds;
+        int cur_node_id;
+        int cur_innov_num;
+
+    public:
+        void init(int node_id, int innov_num);
+        void add(const IndividualInnovation &innov);
+        void apply();
+    };
+} // namespace NEAT
+
+#endif
diff --git a/cpp/brain/innovgenome/innovgenome.cpp b/cpp/brain/innovgenome/innovgenome.cpp
new file mode 100644
index 0000000..ba25952
--- /dev/null
+++ b/cpp/brain/innovgenome/innovgenome.cpp
@@ -0,0 +1,1327 @@
+/*
+  Copyright 2001 The University of Texas at Austin
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+*/
+#include "innovgenome.h"
+#include "protoinnovlinkgene.h"
+#include "recurrencychecker.h"
+#include "util/util.h"
+#include <assert.h>
+#include <cstring>
+
+using namespace NEAT;
+using namespace std;
+
+void InnovGenome::reset() {
+    traits.clear();
+    nodes.clear();
+    links.clear();
+}
+
+InnovGenome::InnovGenome()
+    : node_lookup(nodes) {
+}
+
+InnovGenome::InnovGenome(rng_t rng_,
+                         size_t ntraits,
+                         size_t ninputs,
+                         size_t noutputs,
+                         size_t nhidden)
+    : InnovGenome() {
+
+    rng = rng_;
+
+    for(size_t i = 0; i < ntraits; i++) {
+        traits.emplace_back(i + 1,
+                            rng.prob(),
+                            rng.prob(),
+                            rng.prob(),
+                            rng.prob(),
+                            rng.prob(),
+                            rng.prob(),
+                            rng.prob(),
+                            rng.prob(),
+                            rng.prob());
+    }
+
+    {
+        int node_id = 1;
+
+        //Bias node
+        add_node(nodes, InnovNodeGene(NT_BIAS, node_id++));
+
+        //Sensor nodes
+        for(size_t i = 0; i < ninputs; i++) {
+            add_node(nodes, InnovNodeGene(NT_SENSOR, node_id++));
+        }
+
+        //Output nodes
+        for(size_t i = 0; i < noutputs; i++) {
+            add_node(nodes, InnovNodeGene(NT_OUTPUT, node_id++));
+        }
+
+        //Hidden nodes
+        for(size_t i = 0; i < nhidden; i++) {
+            add_node(nodes, InnovNodeGene(NT_HIDDEN, node_id++));
+        }
+    }
+
+    const int node_id_bias = 1;
+    const int node_id_input = node_id_bias + 1;
+    const int node_id_output = node_id_input + ninputs;
+    const int node_id_hidden = node_id_output + noutputs;
+
+    assert(nhidden > 0);
+
+    int innov = 1;
+
+    //Create links from Bias to all hidden
+    for(size_t i = 0; i < nhidden; i++) {
+        add_link( links, InnovLinkGene(rng.element(traits).trait_id,
+                                       rng.prob(),
+                                       node_id_bias,
+                                       i + node_id_hidden,
+                                       false,
+                                       innov++,
+                                       0.0) );
+    }
+
+    //Create links from all inputs to all hidden
+    for(size_t i = 0; i < ninputs; i++) {
+        for(size_t j = 0; j < nhidden; j++) {
+            add_link( links, InnovLinkGene(rng.element(traits).trait_id,
+                                           rng.prob(),
+                                           i + node_id_input,
+                                           j + node_id_hidden,
+                                           false,
+                                           innov++,
+                                           0.0));
+        }
+    }
+
+    //Create links from all hidden to all output
+    for(size_t i = 0; i < nhidden; i++) {
+        for(size_t j = 0; j < noutputs; j++) {
+            add_link( links, InnovLinkGene(rng.element(traits).trait_id,
+                                           rng.prob(),
+                                           i + node_id_hidden,
+                                           j + node_id_output,
+                                           false,
+                                           innov++,
+                                           0.0));
+        }
+    }
+}
+
+Genome &InnovGenome::operator=(const Genome &other) {
+    return *this = dynamic_cast<const InnovGenome &>(other);
+}
+
+InnovGenome::~InnovGenome() {
+}
+
+void InnovGenome::verify() {
+#ifdef NDEBUG
+    return;
+#else
+
+    //Check for InnovNodeGenes being out of order
+    for(size_t i = 1, n = nodes.size(); i < n; i++) {
+        assert( nodes[i-1].node_id < nodes[i].node_id );
+    }
+
+    {
+        //Check links reference valid nodes.
+        for(InnovLinkGene &gene: links) {
+            assert( get_node(gene.in_node_id()) );
+            assert( get_node(gene.out_node_id()) );
+        }
+    }
+
+    //Make sure there are no duplicate genes
+    for(InnovLinkGene &gene: links) {
+        for(InnovLinkGene &gene2: links) {
+            if(&gene != &gene2) {
+                assert( (gene.is_recurrent() != gene2.is_recurrent())
+                        || (gene2.in_node_id() != gene.in_node_id())
+                        || (gene2.out_node_id() != gene.out_node_id()) );
+            }
+        }
+    }
+#endif
+}
+
+Genome::Stats InnovGenome::get_stats() {
+    return {nodes.size(), links.size()};
+}
+
+void InnovGenome::print(std::ostream &out) {
+    out<<"genomestart "<<genome_id<<std::endl;
+
+    //Output the traits
+    for(auto &t: traits)
+        t.print_to_file(out);
+
+    //Output the nodes
+    for(auto &n: nodes)
+        n.print_to_file(out);
+
+    //Output the genes
+    for(auto &g: links)
+        g.print_to_file(out);
+
+    out << "genomeend " << genome_id << std::endl;
+}
+
+int InnovGenome::get_last_node_id() {
+    return nodes.back().node_id + 1;
+}
+
+real_t InnovGenome::get_last_gene_innovnum() {
+    return links.back().innovation_num + 1;
+}
+
+void InnovGenome::duplicate_into(InnovGenome *offspring) const {
+    offspring->traits = traits;
+    offspring->links = links;
+    offspring->nodes = nodes;
+}
+
+InnovGenome &InnovGenome::operator=(const InnovGenome &other) {
+    rng = other.rng;
+    genome_id = other.genome_id;
+    traits = other.traits;
+    nodes = other.nodes;
+    links = other.links;
+    return *this;
+}
+
+void InnovGenome::mutate_random_trait() {
+    rng.element(traits).mutate(rng);
+}
+
+void InnovGenome::mutate_link_trait(int times) {
+    for(int i = 0; i < times; i++) {
+        int trait_id = 1 + rng.index(traits);
+        InnovLinkGene &gene = rng.element(links);
+
+        if(!gene.frozen) {
+            gene.set_trait_id(trait_id);
+        }
+    }
+}
+
+void InnovGenome::mutate_node_trait(int times) {
+    for(int i = 0; i < times; i++) {
+        int trait_id = 1 + rng.index(traits);
+        InnovNodeGene &node = rng.element(nodes);
+
+        if(!node.frozen) {
+            node.set_trait_id(trait_id);
+        }
+    }
+
+    //TRACK INNOVATION! - possible future use
+    //for any gene involving the mutated node, perturb that gene's
+    //mutation number
+}
+
+void InnovGenome::mutate_link_weights(real_t power,real_t rate,mutator mut_type) {
+    //Go through all the InnovLinkGenes and perturb their link's weights
+
+    real_t num = 0.0; //counts gene placement
+    real_t gene_total = (real_t)links.size();
+    real_t endpart = gene_total*0.8; //Signifies the last part of the genome
+    real_t powermod = 1.0; //Modified power by gene number
+    //The power of mutation will rise farther into the genome
+    //on the theory that the older genes are more fit since
+    //they have stood the test of time
+
+    bool severe = rng.prob() > 0.5;  //Once in a while really shake things up
+
+    //Loop on all links  (ORIGINAL METHOD)
+    for(InnovLinkGene &gene: links) {
+
+        //The following if determines the probabilities of doing cold gaussian
+        //mutation, meaning the probability of replacing a link weight with
+        //another, entirely random weight.  It is meant to bias such mutations
+        //to the tail of a genome, because that is where less time-tested links
+        //reside.  The gausspoint and coldgausspoint represent values above
+        //which a random float will signify that kind of mutation.
+
+        //Don't mutate weights of frozen links
+        if (!(gene.frozen)) {
+            real_t gausspoint;
+            real_t coldgausspoint;
+
+            if (severe) {
+                gausspoint=0.3;
+                coldgausspoint=0.1;
+            }
+            else if ((gene_total>=10.0)&&(num>endpart)) {
+                gausspoint=0.5;  //Mutate by modification % of connections
+                coldgausspoint=0.3; //Mutate the rest by replacement % of the time
+            }
+            else {
+                //Half the time don't do any cold mutations
+                if (rng.prob()>0.5) {
+                    gausspoint=1.0-rate;
+                    coldgausspoint=1.0-rate-0.1;
+                }
+                else {
+                    gausspoint=1.0-rate;
+                    coldgausspoint=1.0-rate;
+                }
+            }
+
+            //Possible methods of setting the perturbation:
+            real_t randnum = rng.posneg()*rng.prob()*power*powermod;
+            if (mut_type==GAUSSIAN) {
+                real_t randchoice = rng.prob();
+                if (randchoice > gausspoint)
+                    gene.weight()+=randnum;
+                else if (randchoice > coldgausspoint)
+                    gene.weight()=randnum;
+            }
+            else if (mut_type==COLDGAUSSIAN)
+                gene.weight()=randnum;
+
+            //Cap the weights at 8.0 (experimental)
+            if (gene.weight() > 8.0) gene.weight() = 8.0;
+            else if (gene.weight() < -8.0) gene.weight() = -8.0;
+
+            //Record the innovation
+            gene.mutation_num = gene.weight();
+
+            num+=1.0;
+        }
+
+    } //end for loop
+}
+
+void InnovGenome::mutate_toggle_enable(int times) {
+    for(int i = 0; i < times; i++) {
+        InnovLinkGene &gene = rng.element(links);
+
+        if(!gene.enable) {
+            gene.enable = true;
+        } else {
+            //We need to make sure that another gene connects out of the in-node
+            //Because if not a section of network will break off and become isolated
+            bool found = false;
+            for(InnovLinkGene &checkgene: links) {
+                if( (checkgene.in_node_id() == gene.in_node_id())
+                    && checkgene.enable
+                    && (checkgene.innovation_num != gene.innovation_num) ) {
+                    found = true;
+                    break;
+                }
+            }
+
+            //Disable the gene if it's safe to do so
+            if(found)
+                gene.enable = false;
+        }
+    }
+}
+
+void InnovGenome::mutate_gene_reenable() {
+    //Search for a disabled gene
+    for(InnovLinkGene &g: links) {
+        if(!g.enable) {
+            g.enable = true;
+            break;
+        }
+    }
+}
+
+bool InnovGenome::mutate_add_node(CreateInnovationFunc create_innov,
+                                  bool delete_split_link) {
+    InnovLinkGene *splitlink = nullptr;
+    {
+        for(int i = 0; !splitlink && i < 20; i++) {
+            InnovLinkGene &g = rng.element(links);
+            //If either the link is disabled, or it has a bias input, try again
+            if( g.enable && get_node(g.in_node_id())->type != NT_BIAS ) {
+                splitlink = &g;
+            }
+        }
+        //We couldn't find anything, so say goodbye!
+        if (!splitlink) {
+            return false;
+        }
+    }
+
+    InnovationId innov_id(splitlink->in_node_id(),
+                          splitlink->out_node_id(),
+                          splitlink->innovation_num);
+    InnovationParms innov_parms;
+
+    auto innov_apply = [this, delete_split_link, splitlink] (const Innovation *innov) {
+
+        InnovNodeGene newnode(NT_HIDDEN, innov->newnode_id);
+
+        InnovLinkGene newlink1(splitlink->trait_id(),
+                               1.0,
+                               innov->id.node_in_id,
+                               innov->newnode_id,
+                               splitlink->is_recurrent(),
+                               innov->innovation_num1,
+                               0);
+
+        InnovLinkGene newlink2(splitlink->trait_id(),
+                               splitlink->weight(),
+                               innov->newnode_id,
+                               innov->id.node_out_id,
+                               false,
+                               innov->innovation_num2,
+                               0);
+
+        if(delete_split_link) {
+            delete_link(splitlink);
+        } else {
+            splitlink->enable = false;
+        }
+
+        add_link(this->links, newlink1);
+        add_link(this->links, newlink2);
+        add_node(this->nodes, newnode);
+    };
+
+    create_innov(innov_id, innov_parms, innov_apply);
+
+    return true;
+}
+
+void InnovGenome::mutate_delete_node() {
+    size_t first_non_io;
+    for(first_non_io = 0; first_non_io < nodes.size(); first_non_io++) {
+        if( nodes[first_non_io].type == NT_HIDDEN ) {
+            break;
+        }
+    }
+
+    //Don't delete if only 0 or 1 hidden nodes
+    if(first_non_io >= (nodes.size()-1)) {
+        return;
+    }
+
+    size_t node_index = rng.index(nodes, first_non_io);
+    InnovNodeGene node = nodes[node_index];
+    assert(node.type == NT_HIDDEN);
+
+    nodes.erase(nodes.begin() + node_index);
+
+    //todo: we should have a way to look up links by in/out id
+    auto it_end = std::remove_if(links.begin(), links.end(),
+                                 [&node] (const InnovLinkGene &link) {
+                                     return link.in_node_id() == node.node_id
+                                     || link.out_node_id() == node.node_id;
+                                 });
+
+    links.resize(it_end - links.begin());
+}
+
+void InnovGenome::mutate_delete_link() {
+    if(links.size() <= 1)
+        return;
+
+    size_t link_index = rng.index(links);
+    InnovLinkGene link = links[link_index];
+    links.erase(links.begin() + link_index);
+
+    delete_if_orphaned_hidden_node(link.in_node_id());
+    delete_if_orphaned_hidden_node(link.out_node_id());
+}
+
+bool InnovGenome::mutate_add_link(CreateInnovationFunc create_innov,
+                                  int tries) {
+    InnovLinkGene *recur_checker_buf[links.size()];
+    RecurrencyChecker recur_checker(nodes.size(), links, recur_checker_buf);
+
+    InnovNodeGene *in_node = nullptr; //Pointers to the nodes
+    InnovNodeGene *out_node = nullptr; //Pointers to the nodes
+
+    //Decide whether to make this recurrent
+    bool do_recur = rng.prob() < env->recur_only_prob;
+
+    // Try to find nodes for link.
+    {
+        bool found_nodes = false;
+
+        //Find the first non-sensor so that the to-node won't look at sensors as
+        //possible destinations
+        int first_nonsensor = 0;
+        for(; is_input(nodes[first_nonsensor].get_type()); first_nonsensor++) {
+        }
+
+        for(int trycount = 0; !found_nodes && (trycount < tries); trycount++) {
+            //Here is the recurrent finder loop- it is done separately
+            if(do_recur) {
+                //Some of the time try to make a recur loop
+                // todo: make this an NE parm?
+                if (rng.prob() > 0.5) {
+                    in_node = &rng.element(nodes, first_nonsensor);
+                    out_node = in_node;
+                }
+                else {
+                    //Choose random nodenums
+                    in_node = &rng.element(nodes);
+                    out_node = &rng.element(nodes, first_nonsensor);
+                }
+            } else {
+                //Choose random nodenums
+                in_node = &rng.element(nodes);
+                out_node = &rng.element(nodes, first_nonsensor);
+            }
+
+            InnovLinkGene *existing_link = find_link(in_node->node_id, out_node->node_id, do_recur);
+            if(existing_link != nullptr) {
+                if( env->mutate_add_link_reenables ) {
+                    existing_link->enable = true;
+                    return true;
+                }
+            } else if(do_recur == recur_checker.is_recur(in_node->node_id,
+                                                         out_node->node_id)) {
+                found_nodes = true;
+            }
+        }
+
+        assert( !is_input(out_node->type) );
+
+        //Continue only if an open link was found
+        if(!found_nodes) {
+            return false;
+        }
+    }
+
+    // Create the gene.
+    {
+        InnovationId innov_id(in_node->node_id,
+                              out_node->node_id,
+                              do_recur);
+
+        //These two values may or may not take effect in the new innovation.
+        //It depends on whether this genome is the first to create the innovation,
+        //but it's impossible to know at this point who is first.
+        int trait_id = 1 + rng.index(traits);
+        real_t newweight = rng.posneg() * rng.prob() * 1.0;
+
+        InnovationParms innov_parms(newweight, trait_id);
+
+        auto innov_apply = [this] (const Innovation *innov) {
+
+            InnovLinkGene newlink(innov->parms.new_trait_id,
+                                  innov->parms.new_weight,
+                                  innov->id.node_in_id,
+                                  innov->id.node_out_id,
+                                  innov->id.recur_flag,
+                                  innov->innovation_num1,
+                                  innov->parms.new_weight);
+
+            add_link(this->links, newlink);
+        };
+
+        create_innov(innov_id, innov_parms, innov_apply);
+    }
+
+    return true;
+}
+
+void InnovGenome::add_link(vector<InnovLinkGene> &llist, const InnovLinkGene &l) {
+    auto it = std::upper_bound(llist.begin(), llist.end(), l, linklist_cmp);
+    llist.insert(it, l);
+}
+
+void InnovGenome::add_node(vector<InnovNodeGene> &nlist, const InnovNodeGene &n) {
+    auto it = std::upper_bound(nlist.begin(), nlist.end(), n, nodelist_cmp);
+    nlist.insert(it, n);
+}
+
+void InnovGenome::mate(InnovGenome *genome1,
+                       InnovGenome *genome2,
+                       InnovGenome *offspring,
+                       real_t fitness1,
+                       real_t fitness2) {
+
+    //Perform mating based on probabilities of differrent mating types
+    if( offspring->rng.prob() < env->mate_multipoint_prob ) {
+        InnovGenome::mate_multipoint(genome1,
+                                     genome2,
+                                     offspring,
+                                     fitness1,
+                                     fitness2);
+    } else {
+        InnovGenome::mate_multipoint_avg(genome1,
+                                         genome2,
+                                         offspring,
+                                         fitness1,
+                                         fitness2);
+    }
+}
+
+// todo: use NodeLookup for newnodes instead of linear search!
+void InnovGenome::mate_multipoint(InnovGenome *genome1,
+                                  InnovGenome *genome2,
+                                  InnovGenome *offspring,
+                                  real_t fitness1,
+                                  real_t fitness2) {
+    rng_t &rng = offspring->rng;
+    vector<InnovLinkGene> &links1 = genome1->links;
+    vector<InnovLinkGene> &links2 = genome2->links;
+
+    //The baby InnovGenome will contain these new Traits, InnovNodeGenes, and InnovLinkGenes
+    offspring->reset();
+    vector<Trait> &newtraits = offspring->traits;
+    vector<InnovNodeGene> &newnodes = offspring->nodes;
+    vector<InnovLinkGene> &newlinks = offspring->links;
+
+    vector<InnovLinkGene>::iterator curgene2;  //Checks for link duplication
+
+    //iterators for moving through the two parents' traits
+    vector<Trait*>::iterator p1trait;
+    vector<Trait*>::iterator p2trait;
+
+    //iterators for moving through the two parents' links
+    vector<InnovLinkGene>::iterator p1gene;
+    vector<InnovLinkGene>::iterator p2gene;
+    real_t p1innov;  //Innovation numbers for links inside parents' InnovGenomes
+    real_t p2innov;
+    vector<InnovNodeGene>::iterator curnode;  //For checking if InnovNodeGenes exist already
+
+    bool disable;  //Set to true if we want to disabled a chosen gene
+
+    disable=false;
+    InnovLinkGene newgene;
+
+    bool p1better; //Tells if the first genome (this one) has better fitness or not
+
+    bool skip;
+
+    //First, average the Traits from the 2 parents to form the baby's Traits
+    //It is assumed that trait lists are the same length
+    //In the future, may decide on a different method for trait mating
+    assert(genome1->traits.size() == genome2->traits.size());
+    for(size_t i = 0, n = genome1->traits.size(); i < n; i++) {
+        newtraits.emplace_back(genome1->traits[i], genome2->traits[i]);
+    }
+
+    //Figure out which genome is better
+    //The worse genome should not be allowed to add extra structural baggage
+    //If they are the same, use the smaller one's disjoint and excess genes only
+    if (fitness1>fitness2)
+        p1better=true;
+    else if (fitness1==fitness2) {
+        if (links1.size()<(links2.size()))
+            p1better=true;
+        else p1better=false;
+    }
+    else
+        p1better=false;
+
+    //Make sure all sensors and outputs are included
+    for(InnovNodeGene &node: genome1->nodes) {
+        if(node.type != NT_HIDDEN) {
+            //Add the new node
+            add_node(newnodes, node);
+        } else {
+            break;
+        }
+    }
+
+    //Now move through the InnovLinkGenes of each parent until both genomes end
+    p1gene = links1.begin();
+    p2gene = links2.begin();
+    while( !((p1gene==links1.end()) && (p2gene==(links2).end())) ) {
+        ProtoInnovLinkGene protogene;
+
+        skip=false;  //Default to not skipping a chosen gene
+
+        if (p1gene==links1.end()) {
+            protogene.set_gene(genome2, &*p2gene);
+            ++p2gene;
+            if (p1better) skip=true;  //Skip excess from the worse genome
+        } else if (p2gene==(links2).end()) {
+            protogene.set_gene(genome1, &*p1gene);
+            ++p1gene;
+            if (!p1better) skip=true; //Skip excess from the worse genome
+        } else {
+            //Extract current innovation numbers
+            p1innov=p1gene->innovation_num;
+            p2innov=p2gene->innovation_num;
+
+            if (p1innov==p2innov) {
+                if (rng.prob()<0.5) {
+                    protogene.set_gene(genome1, &*p1gene);
+                } else {
+                    protogene.set_gene(genome2, &*p2gene);
+                }
+
+                //If one is disabled, the corresponding gene in the offspring
+                //will likely be disabled
+                if (((p1gene->enable)==false)||
+                    ((p2gene->enable)==false))
+                    if (rng.prob()<0.75) disable=true;
+
+                ++p1gene;
+                ++p2gene;
+            } else if (p1innov < p2innov) {
+                protogene.set_gene(genome1, &*p1gene);
+                ++p1gene;
+
+                if (!p1better) skip=true;
+
+            } else if (p2innov<p1innov) {
+                protogene.set_gene(genome2, &*p2gene);
+                ++p2gene;
+
+                if (p1better) skip=true;
+            }
+        }
+
+        //Check to see if the protogene conflicts with an already chosen gene
+        //i.e. do they represent the same link
+        curgene2=newlinks.begin();
+        while ((curgene2!=newlinks.end())&&
+               (!((curgene2->in_node_id()==protogene.gene()->in_node_id())&&
+                  (curgene2->out_node_id()==protogene.gene()->out_node_id())&&(curgene2->is_recurrent()== protogene.gene()->is_recurrent()) ))&&
+               (!((curgene2->in_node_id()==protogene.gene()->out_node_id())&&
+                  (curgene2->out_node_id()==protogene.gene()->in_node_id())&&
+                  (!(curgene2->is_recurrent()))&&
+                  (!(protogene.gene()->is_recurrent())) )))
+        {
+            ++curgene2;
+        }
+
+        if (curgene2!=newlinks.end()) skip=true;  //Links conflicts, abort adding
+
+        if (!skip) {
+            //Now add the gene to the baby
+            InnovNodeGene new_inode;
+            InnovNodeGene new_onode;
+
+            //Next check for the nodes, add them if not in the baby InnovGenome already
+            InnovNodeGene *inode = protogene.in();
+            InnovNodeGene *onode = protogene.out();
+
+            //Check for inode in the newnodes list
+            if (inode->node_id<onode->node_id) {
+                //inode before onode
+
+                //Checking for inode's existence
+                curnode=newnodes.begin();
+                while((curnode!=newnodes.end())&&
+                      (curnode->node_id!=inode->node_id))
+                    ++curnode;
+
+                if (curnode==newnodes.end()) {
+                    //Here we know the node doesn't exist so we have to add it
+                    new_inode = *inode;
+                    add_node(newnodes,new_inode);
+
+                }
+                else {
+                    new_inode=*curnode;
+
+                }
+
+                //Checking for onode's existence
+                curnode=newnodes.begin();
+                while((curnode!=newnodes.end())&&
+                      (curnode->node_id!=onode->node_id))
+                    ++curnode;
+                if (curnode==newnodes.end()) {
+                    //Here we know the node doesn't exist so we have to add it
+                    new_onode = *onode;
+                    add_node(newnodes,new_onode);
+
+                }
+                else {
+                    new_onode=*curnode;
+                }
+
+            }
+            //If the onode has a higher id than the inode we want to add it first
+            else {
+                //Checking for onode's existence
+                curnode=newnodes.begin();
+                while((curnode!=newnodes.end())&&
+                      (curnode->node_id!=onode->node_id))
+                    ++curnode;
+                if (curnode==newnodes.end()) {
+                    //Here we know the node doesn't exist so we have to add it
+                    new_onode = *onode;
+                    //newnodes.push_back(new_onode);
+                    add_node(newnodes,new_onode);
+
+                }
+                else {
+                    new_onode=*curnode;
+
+                }
+
+                //Checking for inode's existence
+                curnode=newnodes.begin();
+                while((curnode!=newnodes.end())&&
+                      (curnode->node_id!=inode->node_id))
+                    ++curnode;
+                if (curnode==newnodes.end()) {
+                    //Here we know the node doesn't exist so we have to add it
+                    new_inode = *inode;
+                    add_node(newnodes,new_inode);
+                }
+                else {
+                    new_inode=*curnode;
+
+                }
+
+            } //End InnovNodeGene checking section- InnovNodeGenes are now in new InnovGenome
+
+            //Add the InnovLinkGene
+            newgene = InnovLinkGene(protogene.gene(),
+                                    protogene.gene()->trait_id(),
+                                    new_inode.node_id,
+                                    new_onode.node_id);
+            if (disable) {
+                newgene.enable=false;
+                disable=false;
+            }
+            newlinks.push_back(newgene);
+        }
+
+    }
+}
+
+// todo: use NodeLookup for newnodes instead of linear search!
+void InnovGenome::mate_multipoint_avg(InnovGenome *genome1,
+                                      InnovGenome *genome2,
+                                      InnovGenome *offspring,
+                                      real_t fitness1,
+                                      real_t fitness2) {
+    rng_t &rng = offspring->rng;
+    vector<InnovLinkGene> &links1 = genome1->links;
+    vector<InnovLinkGene> &links2 = genome2->links;
+
+    //The baby InnovGenome will contain these new Traits, InnovNodeGenes, and InnovLinkGenes
+    offspring->reset();
+    vector<Trait> &newtraits = offspring->traits;
+    vector<InnovNodeGene> &newnodes = offspring->nodes;
+    vector<InnovLinkGene> &newlinks = offspring->links;
+
+    vector<InnovLinkGene>::iterator curgene2; //Checking for link duplication
+
+    //iterators for moving through the two parents' links
+    vector<InnovLinkGene>::iterator p1gene;
+    vector<InnovLinkGene>::iterator p2gene;
+    real_t p1innov;  //Innovation numbers for links inside parents' InnovGenomes
+    real_t p2innov;
+    vector<InnovNodeGene>::iterator curnode;  //For checking if InnovNodeGenes exist already
+
+    //This InnovLinkGene is used to hold the average of the two links to be averaged
+    InnovLinkGene avgene(0,0,0,0,0,0,0);
+    InnovLinkGene newgene;
+
+    bool skip;
+
+    bool p1better;  //Designate the better genome
+
+    //First, average the Traits from the 2 parents to form the baby's Traits
+    //It is assumed that trait lists are the same length
+    //In future, could be done differently
+    for(size_t i = 0, n = genome1->traits.size(); i < n; i++) {
+        newtraits.emplace_back(genome1->traits[i], genome2->traits[i]);
+    }
+
+    //NEW 3/17/03 Make sure all sensors and outputs are included
+    for(InnovNodeGene &node: genome1->nodes) {
+        if(node.type != NT_HIDDEN) {
+            add_node(newnodes, node);
+        } else {
+            break;
+        }
+    }
+
+    //Figure out which genome is better
+    //The worse genome should not be allowed to add extra structural baggage
+    //If they are the same, use the smaller one's disjoint and excess genes only
+    if (fitness1>fitness2)
+        p1better=true;
+    else if (fitness1==fitness2) {
+        if (links1.size()<(links2.size()))
+            p1better=true;
+        else p1better=false;
+    }
+    else
+        p1better=false;
+
+
+    //Now move through the InnovLinkGenes of each parent until both genomes end
+    p1gene=links1.begin();
+    p2gene=links2.begin();
+    while(!((p1gene==links1.end()) && (p2gene==(links2).end()))) {
+        ProtoInnovLinkGene protogene;
+
+        avgene.enable=true;  //Default to enabled
+
+        skip=false;
+
+        if (p1gene==links1.end()) {
+            protogene.set_gene(genome2, &*p2gene);
+            ++p2gene;
+
+            if (p1better) skip=true;
+
+        }
+        else if (p2gene==(links2).end()) {
+            protogene.set_gene(genome1, &*p1gene);
+            ++p1gene;
+
+            if (!p1better) skip=true;
+        }
+        else {
+            //Extract current innovation numbers
+            p1innov=p1gene->innovation_num;
+            p2innov=p2gene->innovation_num;
+
+            if (p1innov==p2innov) {
+                protogene.set_gene(nullptr, &avgene);
+
+                //Average them into the avgene
+                if (rng.prob()>0.5) {
+                    avgene.set_trait_id(p1gene->trait_id());
+                } else {
+                    avgene.set_trait_id(p2gene->trait_id());
+                }
+
+                //WEIGHTS AVERAGED HERE
+                avgene.weight() = (p1gene->weight()+p2gene->weight())/2.0;
+
+                if(rng.prob() > 0.5) {
+                    protogene.set_in(genome1->get_node(p1gene->in_node_id()));
+                } else {
+                    protogene.set_in(genome2->get_node(p2gene->in_node_id()));
+                }
+
+                if(rng.prob() > 0.5) {
+                    protogene.set_out(genome1->get_node(p1gene->out_node_id()));
+                } else {
+                    protogene.set_out(genome2->get_node(p2gene->out_node_id()));
+                }
+
+                if (rng.prob()>0.5) avgene.set_recurrent(p1gene->is_recurrent());
+                else avgene.set_recurrent(p2gene->is_recurrent());
+
+                avgene.innovation_num=p1gene->innovation_num;
+                avgene.mutation_num=(p1gene->mutation_num+p2gene->mutation_num)/2.0;
+
+                if (((p1gene->enable)==false)||
+                    ((p2gene->enable)==false))
+                    if (rng.prob()<0.75) avgene.enable=false;
+
+                ++p1gene;
+                ++p2gene;
+            } else if (p1innov<p2innov) {
+                protogene.set_gene(genome1, &*p1gene);
+                ++p1gene;
+
+                if (!p1better) skip=true;
+            } else if (p2innov<p1innov) {
+                protogene.set_gene(genome2, &*p2gene);
+                ++p2gene;
+
+                if (p1better) skip=true;
+            }
+        }
+
+        //Check to see if the chosengene conflicts with an already chosen gene
+        //i.e. do they represent the same link
+        curgene2=newlinks.begin();
+        while ((curgene2!=newlinks.end()))
+
+        {
+
+            if (((curgene2->in_node_id()==protogene.gene()->in_node_id())&&
+                 (curgene2->out_node_id()==protogene.gene()->out_node_id())&&
+                 (curgene2->is_recurrent()== protogene.gene()->is_recurrent()))||
+                ((curgene2->out_node_id()==protogene.gene()->in_node_id())&&
+                 (curgene2->in_node_id()==protogene.gene()->out_node_id())&&
+                 (!(curgene2->is_recurrent()))&&
+                 (!(protogene.gene()->is_recurrent()))     ))
+            {
+                skip=true;
+
+            }
+            ++curgene2;
+        }
+
+        if (!skip) {
+            //Now add the chosengene to the baby
+
+            //Next check for the nodes, add them if not in the baby InnovGenome already
+            InnovNodeGene *inode = protogene.in();
+            InnovNodeGene *onode = protogene.out();
+
+            //Check for inode in the newnodes list
+            InnovNodeGene new_inode;
+            InnovNodeGene new_onode;
+            if (inode->node_id<onode->node_id) {
+
+                //Checking for inode's existence
+                curnode=newnodes.begin();
+                while((curnode!=newnodes.end())&&
+                      (curnode->node_id!=inode->node_id))
+                    ++curnode;
+
+                if (curnode==newnodes.end()) {
+                    //Here we know the node doesn't exist so we have to add it
+                    new_inode = *inode;
+                    add_node(newnodes,new_inode);
+                }
+                else {
+                    new_inode=(*curnode);
+
+                }
+
+                //Checking for onode's existence
+                curnode=newnodes.begin();
+                while((curnode!=newnodes.end())&&
+                      (curnode->node_id!=onode->node_id))
+                    ++curnode;
+                if (curnode==newnodes.end()) {
+                    //Here we know the node doesn't exist so we have to add it
+                    new_onode = *onode;
+
+                    add_node(newnodes,new_onode);
+                }
+                else {
+                    new_onode=(*curnode);
+                }
+            }
+            //If the onode has a higher id than the inode we want to add it first
+            else {
+                //Checking for onode's existence
+                curnode=newnodes.begin();
+                while((curnode!=newnodes.end())&&
+                      (curnode->node_id!=onode->node_id))
+                    ++curnode;
+                if (curnode==newnodes.end()) {
+                    //Here we know the node doesn't exist so we have to add it
+                    new_onode = *onode;
+
+                    add_node(newnodes,new_onode);
+                }
+                else {
+                    new_onode=(*curnode);
+                }
+
+                //Checking for inode's existence
+                curnode=newnodes.begin();
+                while((curnode!=newnodes.end())&&
+                      (curnode->node_id!=inode->node_id))
+                    ++curnode;
+                if (curnode==newnodes.end()) {
+                    //Here we know the node doesn't exist so we have to add it
+                    new_inode = *inode;
+
+                    add_node(newnodes,new_inode);
+                }
+                else {
+                    new_inode=(*curnode);
+
+                }
+
+            } //End InnovNodeGene checking section- InnovNodeGenes are now in new InnovGenome
+
+            //Add the InnovLinkGene
+            newgene = InnovLinkGene(protogene.gene(),
+                                    protogene.gene()->trait_id(),
+                                    new_inode.node_id,
+                                    new_onode.node_id);
+
+            newlinks.push_back(newgene);
+
+        }  //End if which checked for link duplicationb
+
+    }
+}
+
+real_t InnovGenome::compatibility(InnovGenome *g) {
+    vector<InnovLinkGene> &links1 = this->links;
+    vector<InnovLinkGene> &links2 = g->links;
+
+
+    //Innovation numbers
+    real_t p1innov;
+    real_t p2innov;
+
+    //Intermediate value
+    real_t mut_diff;
+
+    //Set up the counters
+    real_t num_disjoint=0.0;
+    real_t num_excess=0.0;
+    real_t mut_diff_total=0.0;
+    real_t num_matching=0.0;  //Used to normalize mutation_num differences
+
+    //Now move through the InnovLinkGenes of each potential parent
+    //until both InnovGenomes end
+    vector<InnovLinkGene>::iterator p1gene = links1.begin();
+    vector<InnovLinkGene>::iterator p2gene = links2.begin();
+
+    while(!((p1gene==links1.end())&&
+            (p2gene==links2.end()))) {
+
+        if (p1gene==links1.end()) {
+            ++p2gene;
+            num_excess+=1.0;
+        }
+        else if (p2gene==links2.end()) {
+            ++p1gene;
+            num_excess+=1.0;
+        }
+        else {
+            //Extract current innovation numbers
+            p1innov = p1gene->innovation_num;
+            p2innov = p2gene->innovation_num;
+
+            if (p1innov==p2innov) {
+                num_matching+=1.0;
+                mut_diff = p1gene->mutation_num - p2gene->mutation_num;
+                if (mut_diff<0.0) mut_diff=0.0-mut_diff;
+                mut_diff_total+=mut_diff;
+
+                ++p1gene;
+                ++p2gene;
+            }
+            else if (p1innov<p2innov) {
+                ++p1gene;
+                num_disjoint+=1.0;
+            }
+            else if (p2innov<p1innov) {
+                ++p2gene;
+                num_disjoint+=1.0;
+            }
+        }
+    } //End while
+
+    //Return the compatibility number using compatibility formula
+    //Note that mut_diff_total/num_matching gives the AVERAGE
+    //difference between mutation_nums for any two matching InnovLinkGenes
+    //in the InnovGenome
+
+    //Normalizing for genome size
+    //return (disjoint_coeff*(num_disjoint/max_genome_size)+
+    //  excess_coeff*(num_excess/max_genome_size)+
+    //  mutdiff_coeff*(mut_diff_total/num_matching));
+
+
+    //Look at disjointedness and excess in the absolute (ignoring size)
+
+    return (env->disjoint_coeff*(num_disjoint/1.0)+
+            env->excess_coeff*(num_excess/1.0)+
+            env->mutdiff_coeff*(mut_diff_total/num_matching));
+}
+
+real_t InnovGenome::trait_compare(Trait *t1,Trait *t2) {
+
+    int id1=t1->trait_id;
+    int id2=t2->trait_id;
+    int count;
+    real_t params_diff=0.0; //Measures parameter difference
+
+    //See if traits represent different fundamental types of connections
+    if ((id1==1)&&(id2>=2)) {
+        return 0.5;
+    }
+    else if ((id2==1)&&(id1>=2)) {
+        return 0.5;
+    }
+    //Otherwise, when types are same, compare the actual parameters
+    else {
+        if (id1>=2) {
+            for (count=0;count<=2;count++) {
+                params_diff += fabs(t1->params[count]-t2->params[count]);
+            }
+            return params_diff/4.0;
+        }
+        else return 0.0; //For type 1, params are not applicable
+    }
+
+}
+
+void InnovGenome::randomize_traits() {
+    for(InnovNodeGene &node: nodes) {
+        node.set_trait_id(1 + rng.index(traits));
+    }
+
+    for(InnovLinkGene &gene: links) {
+        gene.set_trait_id(1 + rng.index(traits));
+    }
+}
+
+inline Trait &get_trait(vector<Trait> &traits, int trait_id) {
+    Trait &t = traits[trait_id - 1];
+    assert(t.trait_id == trait_id);
+    return t;
+}
+
+Trait &InnovGenome::get_trait(const InnovNodeGene &node) {
+    return ::get_trait(traits, node.get_trait_id());
+}
+
+Trait &InnovGenome::get_trait(const InnovLinkGene &gene) {
+    return ::get_trait(traits, gene.trait_id());
+}
+
+void InnovGenome::init_phenotype(Network &net) {
+    size_t nnodes = nodes.size();
+    assert(nnodes <= NODES_MAX);
+
+    //---
+    //--- Count how many of each type of node.
+    //---
+    NetDims dims;
+    std::memset(&dims, 0, sizeof(dims));
+
+    for(size_t i = 0; i < nnodes; i++) {
+        InnovNodeGene &node = nodes[i];
+
+        switch(node.type) {
+        case NT_BIAS:
+            dims.nnodes.bias++;
+            break;
+        case NT_SENSOR:
+            dims.nnodes.sensor++;
+            break;
+        case NT_OUTPUT:
+            dims.nnodes.output++;
+            break;
+        case NT_HIDDEN:
+            dims.nnodes.hidden++;
+            break;
+        default:
+            panic();
+        }
+    }
+    dims.nnodes.all = nnodes;
+    dims.nnodes.input = dims.nnodes.bias + dims.nnodes.sensor;
+    dims.nnodes.noninput = dims.nnodes.output + dims.nnodes.hidden;
+
+    //---
+    //--- Create unsorted array of links, converting node ID to index in process.
+    //---
+    NetLink netlinks[links.size()];
+    size_t nlinks = 0;
+    size_t node_nlinks[nnodes];
+    memset(node_nlinks, 0, sizeof(size_t) * nnodes);
+
+    for(InnovLinkGene &link: links) {
+        if(link.enable) {
+            NetLink &netlink = netlinks[nlinks++];
+
+            netlink.weight = link.weight();
+            netlink.in_node_index = get_node_index(link.in_node_id());
+            netlink.out_node_index = get_node_index(link.out_node_id());
+
+            node_nlinks[netlink.out_node_index]++;
+        }
+    }
+    assert(nlinks <= LINKS_MAX);
+
+    dims.nlinks = nlinks;
+
+    //---
+    //--- Determine layout of links for each node in sorted array
+    //---
+    NetNode netnodes[nnodes];
+    netnodes[0].incoming_start = 0;
+    netnodes[0].incoming_end = node_nlinks[0];
+    for(size_t i = 1; i < nnodes; i++) {
+        NetNode &prev = netnodes[i-1];
+        NetNode &curr = netnodes[i];
+
+        curr.incoming_start = prev.incoming_end;
+        curr.incoming_end = curr.incoming_start + node_nlinks[i];
+    }
+    assert(netnodes[nnodes - 1].incoming_end == nlinks);
+
+    //---
+    //--- Create sorted links
+    //---
+    memset(node_nlinks, 0, sizeof(size_t) * nnodes);
+    NetLink netlinks_sorted[nlinks];
+    for(size_t i = 0; i < nlinks; i++) {
+        NetLink &netlink = netlinks[i];
+        size_t inode = netlink.out_node_index;
+        size_t isorted = netnodes[inode].incoming_start + node_nlinks[inode]++;
+        netlinks_sorted[isorted] = netlink;
+    }
+
+    //---
+    //--- Configure the net
+    //---
+    net.configure(dims, netnodes, netlinks_sorted);
+}
+
+InnovLinkGene *InnovGenome::find_link(int in_node_id, int out_node_id, bool is_recurrent) {
+    for(InnovLinkGene &g: links) {
+        if( (g.in_node_id() == in_node_id)
+            && (g.out_node_id() == out_node_id)
+            && (g.is_recurrent() == is_recurrent) ) {
+
+            return &g;
+        }
+    }
+
+    return nullptr;
+}
+
+InnovNodeGene *InnovGenome::get_node(int id) {
+    return node_lookup.find(id);
+}
+
+node_size_t InnovGenome::get_node_index(int id) {
+    node_size_t i = get_node(id) - nodes.data();
+    assert(nodes[i].node_id == id);
+    return i;
+}
+
+void InnovGenome::delete_if_orphaned_hidden_node(int node_id) {
+    InnovNodeGene *node = get_node(node_id);
+    if( (node == nullptr) || (node->type != NT_HIDDEN) )
+        return;
+
+    bool found_link;
+    for(InnovLinkGene &link: links) {
+        if(link.in_node_id() == node_id || link.out_node_id() == node_id) {
+            found_link = true;
+            break;
+        }
+    }
+
+    if(!found_link) {
+        auto iterator = nodes.begin() + (node - nodes.data());
+        assert(iterator->node_id == node_id);
+        nodes.erase(iterator);
+    }
+}
+
+void InnovGenome::delete_link(InnovLinkGene *link) {
+    auto iterator = find_if(links.begin(), links.end(),
+                            [link](const InnovLinkGene &l) {
+                                return l.innovation_num == link->innovation_num;
+                            });
+    assert(iterator != links.end());
+    links.erase(iterator);
+}
diff --git a/cpp/brain/innovgenome/innovgenome.h b/cpp/brain/innovgenome/innovgenome.h
new file mode 100644
index 0000000..e6d9447
--- /dev/null
+++ b/cpp/brain/innovgenome/innovgenome.h
@@ -0,0 +1,117 @@
+/*
+ Copyright 2001 The University of Texas at Austin
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+#pragma once
+
+#include "genome.h"
+#include "innovlinkgene.h"
+#include "innovnodegene.h"
+#include "innovnodelookup.h"
+#include "innovation.h"
+
+namespace NEAT {
+
+    class InnovGenome : public Genome {
+    public:
+        std::vector<InnovNodeGene> nodes;
+        std::vector<InnovLinkGene> links;
+
+        int get_last_node_id(); //Return id of final InnovNodeGene in InnovGenome
+        real_t get_last_gene_innovnum(); //Return last innovation number in InnovGenome
+
+        InnovGenome();
+        InnovGenome(rng_t rng,
+                    size_t ntraits,
+                    size_t ninputs,
+                    size_t noutputs,
+                    size_t nhidden);
+
+        virtual Genome &operator=(const Genome &other) override;
+
+        //Destructor kills off all lists (including the trait vector)
+        virtual ~InnovGenome();
+
+        void duplicate_into(InnovGenome *offspring) const;
+        InnovGenome &operator=(const InnovGenome &other);
+
+        // For debugging: A number of tests can be run on a genome to check its
+        // integrity
+        // Note: Some of these tests do not indicate a bug, but rather are meant
+        // to be used to detect specific system states
+        virtual void verify() override;
+        virtual Stats get_stats() override;
+
+        // ******* MUTATORS *******
+
+        // Change random node's trait times times
+        void mutate_node_trait(int times);
+
+        // Add Gaussian noise to linkweights either GAUSSIAN or COLDGAUSSIAN (from zero)
+        void mutate_link_weights(real_t power,real_t rate,mutator mut_type);
+
+
+        // ****** MATING METHODS *****
+        static void mate(InnovGenome *genome1,
+                         InnovGenome *genome2,
+                         InnovGenome *offspring,
+                         real_t fitness1,
+                         real_t fitness2);
+
+        // ******** COMPATIBILITY CHECKING METHODS ********
+
+        // This function gives a measure of compatibility between
+        //   two InnovGenomes by computing a linear combination of 3
+        //   characterizing variables of their compatibilty.
+        //   The 3 variables represent PERCENT DISJOINT GENES,
+        //   PERCENT EXCESS GENES, MUTATIONAL DIFFERENCE WITHIN
+        //   MATCHING GENES.  So the formula for compatibility
+        //   is:  disjoint_coeff*pdg+excess_coeff*peg+mutdiff_coeff*mdmg.
+        //   The 3 coefficients are global system parameters
+        real_t compatibility(InnovGenome *g);
+
+        real_t trait_compare(Trait *t1,Trait *t2);
+
+        // Randomize the trait pointers of all the node and connection genes
+        void randomize_traits();
+
+        Trait &get_trait(const InnovNodeGene &node);
+        Trait &get_trait(const InnovLinkGene &gene);
+
+        InnovNodeGene *get_node(int id);
+        node_size_t get_node_index(int id);
+
+        virtual void init_phenotype(class Network &net) override;
+
+    public:
+        void reset();
+
+        static bool linklist_cmp(const InnovLinkGene &a, const InnovLinkGene &b) {
+            return a.innovation_num < b.innovation_num;
+        }
+
+        //Inserts a InnovNodeGene into a given ordered list of InnovNodeGenes in order
+        static void add_node(std::vector<InnovNodeGene> &nlist, const InnovNodeGene &n);
+
+        //Adds a new gene that has been created through a mutation in the
+        //*correct order* into the list of links in the genome
+        static void add_link(std::vector<InnovLinkGene> &glist, const InnovLinkGene &g);
+
+    private:
+        InnovLinkGene *find_link(int in_node_id, int out_node_id, bool is_recurrent);
+	
+        InnovNodeLookup node_lookup;
+    };
+}
+
diff --git a/cpp/brain/innovgenome/innovgenomemanager.cpp b/cpp/brain/innovgenome/innovgenomemanager.cpp
new file mode 100644
index 0000000..a7b5f2e
--- /dev/null
+++ b/cpp/brain/innovgenome/innovgenomemanager.cpp
@@ -0,0 +1,265 @@
+#include "innovgenome.h"
+#include "innovgenomemanager.h"
+#include "util/util.h"
+#include <memory>
+
+using namespace NEAT;
+
+/* Colin's values
+#define MAX_COMPLEXIFY_PHASE_DURATION 100
+#define MAX_PRUNE_PHASE_DURATION 0.3
+*/
+#define MAX_COMPLEXIFY_PHASE_DURATION 40
+#define PRUNE_PHASE_FACTOR 0.5
+
+InnovGenomeManager::InnovGenomeManager() {
+    if(env->search_type == GeneticSearchType::PHASED) {
+        search_phase = COMPLEXIFY;
+        search_phase_start = 1;
+        max_phase_duration = MAX_COMPLEXIFY_PHASE_DURATION;
+    } else {
+        search_phase = UNDEFINED;
+        search_phase_start = -1;
+        max_phase_duration = 0;
+    }
+    generation = 1;
+}
+
+InnovGenomeManager::~InnovGenomeManager() {
+}
+
+static InnovGenome *to_innov(Genome &g) {
+    return dynamic_cast<InnovGenome *>(&g);
+}
+
+std::unique_ptr<Genome> InnovGenomeManager::make_default() {
+    return std::unique_ptr<Genome>(new InnovGenome());
+}
+
+std::vector<std::unique_ptr<Genome>> InnovGenomeManager::create_seed_generation(size_t ngenomes,
+                                                                      rng_t rng,
+                                                                      size_t ntraits,
+                                                                      size_t ninputs,
+                                                                      size_t noutputs,
+                                                                      size_t nhidden) {
+    InnovGenome start_genome(rng,
+                             ntraits,
+                             ninputs,
+                             noutputs,
+                             nhidden);
+
+    std::vector<std::unique_ptr<Genome>> genomes;
+    {
+        rng_t _rng = rng;
+        for(int i = 0; i < env->pop_size; i++) {
+            InnovGenome *g = new InnovGenome();
+            start_genome.duplicate_into(g);
+            g->rng.seed(_rng.integer());
+            g->mutate_link_weights(1.0,1.0,COLDGAUSSIAN);
+            g->randomize_traits();
+
+            genomes.emplace_back(std::unique_ptr<Genome>(g));
+        }
+    }
+
+    {
+        InnovGenome *g = to_innov(*genomes.back());
+
+        //Keep a record of the innovation and node number we are on
+        innovations.init(g->get_last_node_id(),
+                         g->get_last_gene_innovnum());
+    }
+
+    return genomes;
+}
+
+bool InnovGenomeManager::are_compatible(Genome &genome1,
+                                        Genome &genome2) {
+    return to_innov(genome1)->compatibility(to_innov(genome2)) < env->compat_threshold;
+}
+
+void InnovGenomeManager::clone(Genome &orig,
+                               Genome &clone) {
+    to_innov(orig)->duplicate_into(to_innov(clone));
+}
+
+void InnovGenomeManager::mate(Genome &genome1,
+                              Genome &genome2,
+                              Genome &offspring,
+                              real_t fitness1,
+                              real_t fitness2) {
+
+    if(!is_mate_allowed()) {
+        if(fitness1 > fitness2) {
+            clone(genome1, offspring);
+        } else {
+            clone(genome2, offspring);
+        }
+        mutate(offspring, MUTATE_OP_ANY);
+    } else {
+        InnovGenome::mate(to_innov(genome1),
+                          to_innov(genome2),
+                          to_innov(offspring),
+                          fitness1,
+                          fitness2);
+
+        //Determine whether to mutate the baby's InnovGenome
+        //This is done randomly or if the genome1 and genome2 are the same organism
+        if( !offspring.rng.under(env->mate_only_prob) ||
+            (genome2.genome_id == genome1.genome_id) ||
+            (to_innov(genome2)->compatibility(to_innov(genome1)) == 0.0) ) {
+
+            mutate(offspring, MUTATE_OP_ANY);
+        }
+    }
+}
+
+void InnovGenomeManager::mutate(Genome &genome_,
+                                MutationOperation op) {
+    InnovGenome *genome = to_innov(genome_);
+    bool allow_del = is_delete_allowed();
+    bool allow_add = is_add_allowed();
+
+    switch(op) {
+    case MUTATE_OP_WEIGHTS:
+        genome->mutate_link_weights(env->weight_mut_power,
+                                    1.0,
+                                    GAUSSIAN);
+        break;
+    case MUTATE_OP_STRUCTURE: {
+        if(!allow_add && !allow_del) {
+            mutate(genome_, MUTATE_OP_WEIGHTS);
+        } else {
+            if(!allow_del || genome_.rng.boolean()) {
+                genome->mutate_add_link(create_innov_func(genome_),
+                                        env->newlink_tries);
+            } else {
+                genome->mutate_delete_link();
+            }
+        }
+    } break;
+    case MUTATE_OP_ANY: {
+        rng_t &rng = genome->rng;
+        rng_t::prob_switch_t op = rng.prob_switch();
+
+        if( allow_add && op.prob_case(env->mutate_add_node_prob) ) {
+            bool delete_split_link = env->search_type != GeneticSearchType::COMPLEXIFY;
+            genome->mutate_add_node(create_innov_func(genome_), delete_split_link);
+        } else if( allow_add && op.prob_case(env->mutate_add_link_prob) ) {
+            genome->mutate_add_link(create_innov_func(genome_),
+                                    env->newlink_tries);
+        } else if( allow_del && op.prob_case(env->mutate_delete_link_prob) ) {
+            genome->mutate_delete_link();
+        } else if( allow_del && op.prob_case(env->mutate_delete_node_prob) ) {
+            genome->mutate_delete_node();
+        } else {
+            //Only do other mutations when not doing sturctural mutations
+            if( rng.under(env->mutate_random_trait_prob) ) {
+                genome->mutate_random_trait();
+            }
+            if( rng.under(env->mutate_link_trait_prob) ) {
+                genome->mutate_link_trait(1);
+            }
+            if( rng.under(env->mutate_node_trait_prob) ) {
+                genome->mutate_node_trait(1);
+            }
+            if( rng.under(env->mutate_link_weights_prob) ) {
+                genome->mutate_link_weights(env->weight_mut_power,
+                                            1.0,
+                                            GAUSSIAN);
+            }
+
+            if(env->search_type == GeneticSearchType::COMPLEXIFY) {
+                if( rng.under(env->mutate_toggle_enable_prob) ) {
+                    genome->mutate_toggle_enable(1);
+                }
+                if (rng.under(env->mutate_gene_reenable_prob) ) {
+                    genome->mutate_gene_reenable();
+                }
+            }
+        }
+    } break;
+    default:
+        panic();
+    }
+
+    if(genome->links.size() == 0) {
+        genome->mutate_add_link(create_innov_func(genome_),
+                                env->newlink_tries);
+    }
+}
+
+void InnovGenomeManager::finalize_generation(bool new_fittest) {
+    innovations.apply();
+
+    generation++;
+    if(env->search_type == GeneticSearchType::PHASED) {
+        int phase_duration = generation - search_phase_start;
+        switch(search_phase) {
+        case COMPLEXIFY:
+            if( (phase_duration >= max_phase_duration)
+                || new_fittest) {
+                std::cout << "phase PRUNE @ gen " << generation << std::endl;
+                search_phase_start = generation;
+                search_phase = PRUNE;
+                max_phase_duration = 1 + int(PRUNE_PHASE_FACTOR * phase_duration);
+            }
+            break;
+        case PRUNE:
+            if(phase_duration >= max_phase_duration) {
+                std::cout << "phase COMPLEXIFY @ gen " << generation << std::endl;
+                search_phase_start = generation;
+                search_phase = COMPLEXIFY;
+                max_phase_duration = MAX_COMPLEXIFY_PHASE_DURATION;
+            }
+            break;
+        default:
+            panic();
+        }
+    }
+}
+
+CreateInnovationFunc InnovGenomeManager::create_innov_func(Genome &g) {
+    return [this, &g] (InnovationId id,
+                       InnovationParms parms,
+                       IndividualInnovation::ApplyFunc apply) {
+        innovations.add(IndividualInnovation(g.genome_id, id, parms, apply));
+    };
+}
+
+bool InnovGenomeManager::is_mate_allowed() {
+    switch(env->search_type) {
+    case GeneticSearchType::PHASED:
+        return search_phase == COMPLEXIFY;
+    case GeneticSearchType::BLENDED:
+    case GeneticSearchType::COMPLEXIFY:
+        return true;
+    default:
+        panic();
+    }
+}
+
+bool InnovGenomeManager::is_add_allowed() {
+    switch(env->search_type) {
+    case GeneticSearchType::PHASED:
+        return search_phase == COMPLEXIFY;
+    case GeneticSearchType::BLENDED:
+    case GeneticSearchType::COMPLEXIFY:
+        return true;
+    default:
+        panic();
+    }
+}
+
+bool InnovGenomeManager::is_delete_allowed() {
+    switch(env->search_type) {
+    case GeneticSearchType::PHASED:
+        return search_phase == PRUNE;
+    case GeneticSearchType::BLENDED:
+        return true;
+    case GeneticSearchType::COMPLEXIFY:
+        return false;
+    default:
+        panic();
+    }
+}
diff --git a/cpp/brain/innovgenome/innovgenomemanager.h b/cpp/brain/innovgenome/innovgenomemanager.h
new file mode 100644
index 0000000..ce66dcd
--- /dev/null
+++ b/cpp/brain/innovgenome/innovgenomemanager.h
@@ -0,0 +1,59 @@
+#pragma once
+
+#include "genomemanager.h"
+#include "innovation.h"
+
+namespace NEAT {
+
+    class InnovGenomeManager : public GenomeManager {
+        friend class GenomeManager;
+    protected:
+        InnovGenomeManager();
+    public:
+        virtual ~InnovGenomeManager();
+
+        virtual std::unique_ptr<Genome> make_default() override;
+
+        virtual std::vector<std::unique_ptr<Genome>> create_seed_generation(size_t ngenomes,
+                                                                            class rng_t rng,
+                                                                            size_t ntraits,
+                                                                            size_t ninputs,
+                                                                            size_t noutputs,
+                                                                            size_t nhidden) override;
+
+        virtual bool are_compatible(Genome &genome1,
+                                    Genome &genome2) override;
+
+        virtual void clone(Genome &orig,
+                           Genome &clone) override;
+
+        virtual void mate(Genome &genome1,
+                          Genome &genome2,
+                          Genome &offspring,
+                          real_t fitness1,
+                          real_t fitness2) override;
+
+        virtual void mutate(Genome &genome,
+                            MutationOperation op = MUTATE_OP_ANY) override;
+
+        virtual void finalize_generation(bool new_fittest) override;
+
+    protected:
+        CreateInnovationFunc create_innov_func(Genome &g);
+        bool is_mate_allowed();
+        bool is_add_allowed();
+        bool is_delete_allowed();
+
+        PopulationInnovations innovations;
+
+        int generation;
+        enum SearchPhase {
+            UNDEFINED,
+            COMPLEXIFY,
+            PRUNE
+        } search_phase;
+        int search_phase_start;
+        int max_phase_duration;
+    };
+
+}
diff --git a/cpp/brain/innovgenome/innovlinkgene.cpp b/cpp/brain/innovgenome/innovlinkgene.cpp
new file mode 100644
index 0000000..18968a3
--- /dev/null
+++ b/cpp/brain/innovgenome/innovlinkgene.cpp
@@ -0,0 +1,129 @@
+/*
+  Copyright 2001 The University of Texas at Austin
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+*/
+#include "innovlinkgene.h"
+#include <sstream>
+
+using namespace NEAT;
+
+InnovLinkGene::InnovLinkGene(real_t w,
+                             int inode_id,
+                             int onode_id,
+                             bool recur,
+                             int innov,
+                             real_t mnum) {
+    _weight = w;
+    _in_node_id = inode_id;
+    _out_node_id = onode_id;
+    _is_recurrent = recur;
+    _trait_id = 1;
+
+    innovation_num = innov;
+    mutation_num = mnum;
+    enable = true;
+    frozen = false;
+}
+
+
+//Construct a gene with a trait
+InnovLinkGene::InnovLinkGene(int trait_id,
+                             real_t w,
+                             int inode_id,
+                             int onode_id,
+                             bool recur,
+                             int innov,
+                             real_t mnum) {
+    _weight = w;
+    _in_node_id = inode_id;
+    _out_node_id = onode_id;
+    _is_recurrent = recur;
+    _trait_id = trait_id;
+
+    innovation_num=innov;
+    mutation_num=mnum;
+    enable=true;
+    frozen=false;
+}
+
+InnovLinkGene::InnovLinkGene(InnovLinkGene *g,
+                             int trait_id,
+                             int inode_id,
+                             int onode_id) {
+    _weight = g->_weight;
+    _in_node_id = inode_id;
+    _out_node_id = onode_id;
+    _is_recurrent = g->_is_recurrent;
+    _trait_id = trait_id;
+
+    innovation_num=g->innovation_num;
+    mutation_num=g->mutation_num;
+    enable=g->enable;
+
+    frozen=g->frozen;
+}
+
+//todo: use NodeLookup
+InnovLinkGene::InnovLinkGene(const char *argline) {
+    //InnovLinkGene parameter holders
+    int trait_id;
+    int inodenum;
+    int onodenum;
+    real_t weight;
+    int recur;
+
+    //Get the gene parameters
+    std::stringstream ss(argline);
+    ss >> trait_id >> inodenum >> onodenum >> weight >> recur >> innovation_num >> mutation_num >> enable;
+
+    frozen=false; //TODO: MAYBE CHANGE
+
+    _weight = weight;
+    _in_node_id = inodenum;
+    _out_node_id = onodenum;
+    _is_recurrent = recur;
+    _trait_id = trait_id;
+}
+
+InnovLinkGene::InnovLinkGene(const InnovLinkGene& gene)
+{
+    innovation_num = gene.innovation_num;
+    mutation_num = gene.mutation_num;
+    enable = gene.enable;
+    frozen = gene.frozen;
+
+    _weight = gene._weight;
+    _in_node_id = gene._in_node_id;
+    _out_node_id = gene._out_node_id;
+    _is_recurrent = gene._is_recurrent;
+    _trait_id = gene._trait_id;
+}
+
+InnovLinkGene::~InnovLinkGene() {
+}
+
+
+void InnovLinkGene::print_to_file(std::ostream &outFile) {
+    outFile<<"gene ";
+
+    //Start off with the trait number for this gene
+    outFile << _trait_id << " ";
+    outFile << _in_node_id << " ";
+    outFile << _out_node_id << " ";
+    outFile << _weight << " ";
+    outFile << _is_recurrent << " ";
+    outFile << innovation_num << " ";
+    outFile << mutation_num << " ";
+    outFile << enable << std::endl;
+}
diff --git a/cpp/brain/innovgenome/innovlinkgene.h b/cpp/brain/innovgenome/innovlinkgene.h
new file mode 100644
index 0000000..9f0ee74
--- /dev/null
+++ b/cpp/brain/innovgenome/innovlinkgene.h
@@ -0,0 +1,94 @@
+/*
+ Copyright 2001 The University of Texas at Austin
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+#ifndef _GENE_H_
+#define _GENE_H_
+
+#include "neat.h"
+#include "trait.h"
+#include "network/network.h"
+
+namespace NEAT {
+
+    class InnovLinkGene {
+        real_t _weight; // Weight of connection
+        int _in_node_id; // NNode inputting into the link
+        int _out_node_id; // NNode that the link affects
+        bool _is_recurrent;
+        int _trait_id;  // identify the trait derived by this link
+
+    public:
+        inline int out_node_id() const { return _out_node_id; }
+        inline void set_out_node_id(int id) { _out_node_id = id; }
+
+        inline int in_node_id() const { return _in_node_id; }
+        inline void set_in_node_id(int id) { _in_node_id = id; }
+
+        inline real_t &weight() { return _weight; }
+
+        inline int trait_id() const { return _trait_id; }
+        inline void set_trait_id(int tid) { _trait_id = tid; }
+
+        inline bool is_recurrent() const { return _is_recurrent; }
+        inline void set_recurrent(bool r) { _is_recurrent = r; }
+
+
+        int innovation_num;
+        real_t mutation_num;  //Used to see how much mutation has changed the link
+        bool enable;  //When this is off the InnovLinkGene is disabled
+        bool frozen;  //When frozen, the linkweight cannot be mutated
+
+        // Construct a gene in an invalid default state.
+        InnovLinkGene() {}
+
+        //Construct a gene with no trait
+        InnovLinkGene(real_t w,
+                 int inode_id,
+                 int onode_id,
+                 bool recur,
+                 int innov,
+                 real_t mnum);
+
+        //Construct a gene with a trait
+        InnovLinkGene(int trait_id,
+                 real_t w,
+                 int inode_id,
+                 int onode_id,
+                 bool recur,
+                 int innov,
+                 real_t mnum);
+
+        //Construct a gene off of another gene as a duplicate
+        InnovLinkGene(InnovLinkGene *g,
+                 int trait_id,
+                 int inode_id,
+                 int onode_id);
+
+        //Construct a gene from a file spec given traits and nodes
+        InnovLinkGene(const char *argline);
+
+        // Copy Constructor
+        InnovLinkGene(const InnovLinkGene& gene);
+
+        ~InnovLinkGene();
+
+        //Print gene to a file- called from Genome
+        void print_to_file(std::ostream &outFile);
+    };
+
+} // namespace NEAT
+
+
+#endif
diff --git a/cpp/brain/innovgenome/innovnodegene.cpp b/cpp/brain/innovgenome/innovnodegene.cpp
new file mode 100644
index 0000000..b71f5a1
--- /dev/null
+++ b/cpp/brain/innovgenome/innovnodegene.cpp
@@ -0,0 +1,48 @@
+/*
+  Copyright 2001 The University of Texas at Austin
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+*/
+#include "innovnodegene.h"
+#include <sstream>
+using namespace NEAT;
+
+InnovNodeGene::InnovNodeGene(nodetype ntype,int nodeid) {
+    type=ntype; //NEURON or SENSOR type
+    node_id=nodeid;
+    frozen=false;
+    trait_id=1;
+}
+
+InnovNodeGene::InnovNodeGene (const char *argline) {
+    std::stringstream ss(argline);
+    int nodety, nodepl;
+    ss >> node_id >> trait_id >> nodety >> nodepl;
+    type = (nodetype)nodety;
+
+    if(trait_id == 0)
+        trait_id = 1;
+
+    // Get the Sensor Identifier and Parameter String
+    // mySensor = SensorRegistry::getSensor(id, param);
+    frozen=false;  //TODO: Maybe change
+}
+
+InnovNodeGene::~InnovNodeGene() {
+}
+
+void InnovNodeGene::print_to_file(std::ostream &outFile) {
+    outFile<<"node "<<node_id<<" ";
+    outFile<<trait_id<<" ";
+    outFile<<(int)type<<std::endl;
+}
diff --git a/cpp/brain/innovgenome/innovnodegene.h b/cpp/brain/innovgenome/innovnodegene.h
new file mode 100644
index 0000000..7545c71
--- /dev/null
+++ b/cpp/brain/innovgenome/innovnodegene.h
@@ -0,0 +1,50 @@
+/*
+ Copyright 2001 The University of Texas at Austin
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+#pragma once
+
+#include <assert.h>
+#include "neat.h"
+#include <iostream>
+
+namespace NEAT {
+
+    class InnovNodeGene {
+        int trait_id;  // identify the trait derived by this node
+    public:
+        bool frozen; // When frozen, cannot be mutated (meaning its trait pointer is fixed)
+        nodetype type;
+        int node_id;  // A node can be given an identification number for saving in files
+
+        // Construct InnovNodeGene with invalid state.
+        InnovNodeGene() {}
+        InnovNodeGene(nodetype ntype,int nodeid);
+        // Construct the node out of a file specification using given list of traits
+        InnovNodeGene (const char *argline);
+
+        ~InnovNodeGene();
+
+        inline void set_trait_id(int id) { assert(id > 0); trait_id = id; }
+        inline int get_trait_id() const {return trait_id;}
+
+        inline const nodetype get_type() const {return type;}
+        inline void set_type(nodetype t) {type = t;}
+
+        // Print the node to a file
+        void  print_to_file(std::ostream &outFile);
+    };
+
+} // namespace NEAT
+
diff --git a/cpp/brain/innovgenome/innovnodelookup.h b/cpp/brain/innovgenome/innovnodelookup.h
new file mode 100644
index 0000000..c791918
--- /dev/null
+++ b/cpp/brain/innovgenome/innovnodelookup.h
@@ -0,0 +1,41 @@
+#pragma once
+
+#include "innovnodegene.h"
+#include <vector>
+#include <algorithm>
+
+namespace NEAT {
+
+    inline bool nodelist_cmp(const InnovNodeGene &a, const InnovNodeGene &b) {
+        return a.node_id < b.node_id;
+    }
+    inline bool nodelist_cmp_key(const InnovNodeGene &node, int node_id) {
+        return node.node_id < node_id;
+    }
+
+    class InnovNodeLookup {
+        std::vector<InnovNodeGene> &nodes;
+    public:
+        // Must be sorted by node_id in ascending order
+    InnovNodeLookup(std::vector<InnovNodeGene> &nodes_)
+        : nodes(nodes_) {
+        }
+
+        InnovNodeGene *find(int node_id) {
+            auto it = std::lower_bound(nodes.begin(), nodes.end(), node_id, nodelist_cmp_key);
+            if(it == nodes.end())
+                return nullptr;
+
+            InnovNodeGene &node = *it;
+            if(node.node_id != node_id)
+                return nullptr;
+
+            return &node;
+        }
+
+        InnovNodeGene *find(InnovNodeGene *n) {
+            return find(n->node_id);
+        }
+    };
+
+}
diff --git a/cpp/brain/innovgenome/protoinnovlinkgene.h b/cpp/brain/innovgenome/protoinnovlinkgene.h
new file mode 100644
index 0000000..3c51129
--- /dev/null
+++ b/cpp/brain/innovgenome/protoinnovlinkgene.h
@@ -0,0 +1,37 @@
+#pragma once
+
+namespace NEAT {
+
+    class ProtoInnovLinkGene {
+        InnovGenome *_genome = nullptr;
+        //todo: does this have to be a InnovLinkGene* now?
+        InnovLinkGene *_gene = nullptr;
+        InnovNodeGene *_in = nullptr;
+        InnovNodeGene *_out = nullptr;
+    public:
+        void set_gene(InnovGenome *genome, InnovLinkGene *gene) {
+            _genome = genome;
+            _gene = gene;
+        }
+        InnovLinkGene *gene() {
+            return _gene;
+        }
+
+        void set_out(InnovNodeGene *out) {
+            _out = out;
+            _gene->set_out_node_id(out->node_id);
+        }
+        InnovNodeGene *out() {
+            return _out ? _out : _genome->get_node(_gene->out_node_id());
+        }
+
+        void set_in(InnovNodeGene *in) {
+            _in = in;
+            _gene->set_in_node_id(in->node_id);
+        }
+        InnovNodeGene *in() {
+            return _in ? _in : _genome->get_node(_gene->in_node_id());
+        }
+    };
+
+}
diff --git a/cpp/brain/innovgenome/recurrencychecker.h b/cpp/brain/innovgenome/recurrencychecker.h
new file mode 100644
index 0000000..ded76b4
--- /dev/null
+++ b/cpp/brain/innovgenome/recurrencychecker.h
@@ -0,0 +1,101 @@
+#pragma once
+
+namespace NEAT {
+
+    class RecurrencyChecker {
+    private:
+        size_t nnodes;
+        InnovLinkGene **links;
+        size_t nlinks;
+
+        static bool cmp_sort(const InnovLinkGene *x, const InnovLinkGene *y) {
+            return x->out_node_id() < y->out_node_id();
+        }
+
+        static bool cmp_find(const InnovLinkGene *x, int node_id) {
+            return x->out_node_id() < node_id;
+        }
+
+        bool find(int node_id, InnovLinkGene ***curr) {
+            if(*curr == nullptr) {
+                auto it = std::lower_bound(links, links + nlinks, node_id, cmp_find);
+                if(it == links + nlinks) return false;
+                if((*it)->out_node_id() != node_id) return false;
+
+                *curr = it;
+                return true;
+            } else {
+                (*curr)++;
+                if(*curr >= (links + nlinks)) return false;
+                if((**curr)->out_node_id() != node_id) return false;
+                return true;
+            }
+        }
+
+        // This checks a POTENTIAL link between a potential in_node and potential out_node to see if it must be recurrent
+        bool is_recur(int in_id, int out_id, int &count, int thresh) {
+            ++count;  //Count the node as visited
+            if(count > thresh) {
+                return false;  //Short out the whole thing- loop detected
+            }
+
+            if (in_id==out_id) return true;
+            else {
+                InnovLinkGene **gene = nullptr;
+                while( find(in_id, &gene) ) {
+                    //But skip links that are already recurrent
+                    //(We want to check back through the forward flow of signals only
+                    if(!(*gene)->is_recurrent()) {
+                        if( is_recur((*gene)->in_node_id(), out_id, count, thresh) )
+                            return true;
+                    }
+                }
+                return false;
+            }
+        }
+
+    public:
+        RecurrencyChecker(size_t nnodes_,
+                          std::vector<InnovLinkGene> &genome_links,
+                          InnovLinkGene **buf_links) {
+            nnodes = nnodes_;
+            links = buf_links;
+
+            nlinks = 0;
+            for(size_t i = 0; i < genome_links.size(); i++) {
+                InnovLinkGene *g = &genome_links[i];
+                if(g->enable) {
+                    links[nlinks++] = g;
+                }
+            }
+            std::sort(links, links + nlinks, cmp_sort);
+        }
+
+        bool is_recur(int in_node_id, int out_node_id) {
+            //These are used to avoid getting stuck in an infinite loop checking
+            //for recursion
+            //Note that we check for recursion to control the frequency of
+            //adding recurrent links rather than to prevent any paricular
+            //kind of error
+            int thresh=nnodes*nnodes;
+            int count = 0;
+
+            if(is_recur(in_node_id, out_node_id, count, thresh)) {
+                return true;
+            }
+
+            //ADDED: CONSIDER connections out of outputs recurrent
+            //todo: this was fixed to use place instead of type,
+            //      but not clear if this logic is desirable. Shouldn't it
+            //      just be checking if the output node is OUTPUT?
+            /*
+              if (((in_node->place)==OUTPUT)||
+              ((out_node->place)==OUTPUT))
+              return true;
+            */
+            return false;
+        }
+
+    };
+
+}
diff --git a/cpp/brain/innovgenome/trait.cpp b/cpp/brain/innovgenome/trait.cpp
new file mode 100644
index 0000000..8684bfe
--- /dev/null
+++ b/cpp/brain/innovgenome/trait.cpp
@@ -0,0 +1,103 @@
+/*
+ Copyright 2001 The University of Texas at Austin
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+
+#include "trait.h"
+#include <sstream>
+
+using namespace NEAT;
+
+Trait::Trait () {
+    for (int count=0;count<NUM_TRAIT_PARAMS;count++)
+        params[count]=0;
+    trait_id=0;
+}
+
+Trait::Trait(int id,real_t p1,real_t p2,real_t p3,real_t p4,real_t p5,real_t p6,real_t p7,real_t p8,real_t p9) {
+    trait_id=id;
+    params[0]=p1;
+    params[1]=p2;
+    params[2]=p3;
+    params[3]=p4;
+    params[4]=p5;
+    params[5]=p6;
+    params[6]=p7;
+    params[7]=0;
+}
+
+Trait::Trait(const Trait& t) {
+    for(int count=0; count < NUM_TRAIT_PARAMS; count++)
+        params[count]=(t.params)[count];
+
+    trait_id = t.trait_id;
+}
+
+
+Trait::Trait(Trait *t) {
+    for(int count=0;count<NUM_TRAIT_PARAMS;count++)
+        params[count]=(t->params)[count];
+
+    trait_id=t->trait_id;
+}
+
+
+Trait::Trait(const char *argline) {
+
+    std::stringstream ss(argline);
+    //Read in trait id
+ //   std::string curword;
+    //char delimiters[] = " \n";
+    //int curwordnum = 0;
+
+    //strcpy(curword, env->getUnit(argline, curwordnum++, delimiters));
+
+//    trait_id = atoi(curword);
+    ss >> trait_id;
+
+    //std::cout << ss.str() << " trait_id: " << trait_id << std::endl;
+
+    //IS THE STOPPING CONDITION CORRECT?  ALERT
+    for(int count=0;count<NUM_TRAIT_PARAMS;count++) {
+        //strcpy(curword, env->getUnit(argline, curwordnum++, delimiters));
+        //params[count] = atof(curword);
+        ss >> params[count];
+        //iFile>>params[count];
+    }
+
+}
+
+Trait::Trait(const Trait &t1, const Trait &t2) {
+    trait_id = t1.trait_id;
+    for(int count=0; count < NUM_TRAIT_PARAMS; count++)
+        params[count] = (t1.params[count] + t2.params[count]) / 2.0;
+}
+
+void Trait::print_to_file(std::ostream &outFile) {
+  outFile<<"trait "<<trait_id<<" ";
+  for(int count=0;count<NUM_TRAIT_PARAMS;count++)
+    outFile<<params[count]<<" ";
+
+  outFile<<std::endl;
+}
+
+void Trait::mutate(rng_t &rng) {
+    for(int count=0;count<NUM_TRAIT_PARAMS;count++) {
+        if (rng.prob()>env->trait_param_mut_prob) {
+            params[count]+=(rng.posneg()*rng.prob())*env->trait_mutation_power;
+            if (params[count]<0) params[count]=0;
+            if (params[count]>1.0) params[count]=1.0;
+        }
+    }
+}
diff --git a/cpp/brain/innovgenome/trait.h b/cpp/brain/innovgenome/trait.h
new file mode 100644
index 0000000..6f9d265
--- /dev/null
+++ b/cpp/brain/innovgenome/trait.h
@@ -0,0 +1,69 @@
+/*
+ Copyright 2001 The University of Texas at Austin
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+#ifndef _TRAIT_H_
+#define _TRAIT_H_
+
+#include "neat.h"
+#include "util/rng.h"
+
+namespace NEAT {
+
+    const int NUM_TRAIT_PARAMS = 8;
+
+    // ------------------------------------------------------------------
+    // TRAIT: A Trait is a group of parameters that can be expressed
+    //        as a group more than one time.  Traits save a genetic
+    //        algorithm from having to search vast parameter landscapes
+    //        on every node.  Instead, each node can simply point to a trait
+    //        and those traits can evolve on their own
+    class Trait {
+
+        // ************ LEARNING PARAMETERS ***********
+        // The following parameters are for use in
+        //   neurons that learn through habituation,
+        //   sensitization, or Hebbian-type processes
+
+    public:
+        int trait_id; // Used in file saving and loading
+        real_t params[NUM_TRAIT_PARAMS]; // Keep traits in an array
+
+        Trait ();
+
+        Trait(int id,real_t p1,real_t p2,real_t p3,real_t p4,real_t p5,real_t p6,real_t p7,real_t p8,real_t p9);
+
+        // Copy Constructor
+        Trait(const Trait& t);
+
+        // Create a trait exactly like another trait
+        Trait(Trait *t);
+
+        // Special constructor off a file assume word "trait" has been read in
+        Trait(const char *argline);
+
+        // Special Constructor creates a new Trait which is the average of 2 existing traits passed in
+        Trait(const Trait &t1, const Trait &t2);
+
+        // Dump trait to a stream
+        void print_to_file(std::ostream &outFile);
+
+        // Perturb the trait parameters slightly
+        void mutate(rng_t &rng);
+
+    };
+
+} // namespace NEAT
+
+#endif
diff --git a/cpp/brain/split_cpg/converting_split_brain.h b/cpp/brain/split_cpg/converting_split_brain.h
index ae7126a..378f546 100644
--- a/cpp/brain/split_cpg/converting_split_brain.h
+++ b/cpp/brain/split_cpg/converting_split_brain.h
@@ -27,10 +27,12 @@ public:
                         double t,
                         double step) 
     {
-	if ((t - start_eval_time_) > evaluation_rate_ && generation_counter_ < max_evaluations_) {
+	if (start_eval_time_ == 0 || (t - start_eval_time_) > evaluation_rate_ && generation_counter_ < max_evaluations_) {
 	    double fitness = evaluator_->fitness();
-	    std::cout << fitness << std::endl;
-	    this->learner->reportFitness("test", convertForLearner_(this->controller->getGenome()), fitness);
+	    if(start_eval_time_ != 0) {
+		std::cout << fitness << std::endl;
+		this->learner->reportFitness("test", convertForLearner_(this->controller->getGenome()), fitness);
+	    }
 	    this->controller->setGenome(convertForController_(this->learner->getNewGenome("test")));
 	    start_eval_time_ = t;
 	    evaluator_->start();
diff --git a/cpp/brain/split_cpg/spline_controller.h b/cpp/brain/split_cpg/spline_controller.h
new file mode 100644
index 0000000..478a799
--- /dev/null
+++ b/cpp/brain/split_cpg/spline_controller.h
@@ -0,0 +1,201 @@
+//
+// Created by Milan Jelisavcic on 28/03/16.
+//
+
+#ifndef REVOLVE_BRAIN_SPLINE_CONTROLLER_H
+#define REVOLVE_BRAIN_SPLINE_CONTROLLER_H
+
+#include "controller.h"
+
+#include <cmath>
+#include <string>
+
+
+namespace revolve {
+    namespace brain {
+
+//    typedef std::vector<double> Spline;
+//    typedef std::vector<Spline *> Policy;
+
+        class SplineController : public revolve::brain::Controller<std::vector<std::vector<double>>> {
+	protected:
+	    struct Config;
+        public:
+            typedef std::vector<double> Spline;
+            typedef std::vector<Spline> Policy;
+            typedef std::shared_ptr<Policy> PolicyPtr;
+            /**
+             * The RLPower constructor reads out configuration file, deretmines which algorithm type to apply and
+             * initialises new policy.
+             * @param modelName: name of a robot
+             * @param brain: configuration file
+             * @param evaluator: pointer to fitness evaluatior
+             * @param n_actuators: number of actuators
+             * @param n_sensors: number of sensors
+             * @return pointer to the RLPower class object
+             */
+            SplineController(std::string modelName,
+                    Config brain,
+                    EvaluatorPtr evaluator,
+                    unsigned int n_actuators,
+                    unsigned int n_sensors);
+
+            virtual ~SplineController();
+
+            /**
+             * Method for updating sensors readings, actuators positions, ranked list of policies and generating new policy
+             * @param actuators: vector list of robot's actuators
+             * @param sensors: vector list of robot's sensors
+             * @param t:
+             * @param step:
+             */
+            virtual void update(const std::vector<ActuatorPtr> &actuators,
+                                const std::vector<SensorPtr> &sensors,
+                                double t,
+                                double step);
+	    /**
+	    * Get method for the genome
+	    * @return current genome
+	    */
+	    virtual G getGenome();
+	    
+	    /**
+	    * Set method for the genome
+	    * @param newGenome: new genome to use instead of the old one
+	    */
+	    virtual void setGenome(G newGenome);
+      
+        protected:
+//        /**
+//         * Request handler to modify the neural network
+//         */
+//        void modify(ConstModifyNeuralNetworkPtr &req);
+//
+//        boost::mutex networkMutex_; // Mutex for stepping / updating the network
+
+            /**
+             * Ranked list of used splines
+             */
+            class PolicySave {
+            public:
+                PolicyPtr policy_;
+                double fitness_;
+
+                PolicySave(double fitness, PolicyPtr &p) :
+                        policy_(p),
+                        fitness_(fitness) {}
+
+                bool operator>(const PolicySave &ps) const {
+                    return this->fitness_ > ps.fitness_;
+                }
+            };
+
+            static const unsigned int MAX_EVALUATIONS;// = 1000; // max number of evaluations
+            static const unsigned int MAX_RANKED_POLICIES;// = 10; // max length of policies vector
+            static const unsigned int INTERPOLATION_CACHE_SIZE;// = 100; // number of data points for the interpolation cache
+            static const unsigned int INITIAL_SPLINE_SIZE;// = 3; // number of initially sampled spline points
+            static const unsigned int UPDATE_STEP;// = 100; // after # generations, it increases the number of spline points
+            static const double EVALUATION_RATE;// = 30.0; // evaluation time for each policy
+            static const double SIGMA_START_VALUE;// = 0.8; // starting value for sigma
+            static const double SIGMA_TAU_CORRECTION;// = 0.2;
+
+            static const double CYCLE_LENGTH;// = 5; // seconds
+            static const double SIGMA_DECAY_SQUARED;// = 0.98; // sigma decay
+
+            template<typename ActuatorContainer, typename SensorContainer>
+            void update(const ActuatorContainer &actuators,
+                        const SensorContainer &sensors,
+                        double t,
+                        double step) {
+
+                // generate outputs
+                double *output_vector = new double[n_actuators_];
+                this->generateOutput(t, output_vector);
+
+                // Send new signals to the actuators
+                unsigned int p = 0;
+                for (auto actuator: actuators) {
+                    actuator->update(&output_vector[p], step);
+                    p += actuator->outputs();
+                }
+
+                delete[] output_vector;
+            }
+
+            struct Config {
+                std::string algorithm_type;
+                unsigned int evaluation_rate;
+                unsigned int interpolation_spline_size;
+                unsigned int max_evaluations;
+                unsigned int max_ranked_policies;
+                double noise_sigma;
+                double sigma_tau_correction;
+                unsigned int source_y_size;
+                unsigned int update_step;
+                std::string policy_load_path;
+            };
+
+        private:
+
+            /**
+             * Generate cache policy
+             */
+            void generateCache();
+            /**
+             * Generate interpolated spline based on number of sampled control points in 'source_y'
+             * @param source_y: set of control points over which interpolation is generated
+             * @param destination_y: set of interpolated control points (default 100 points)
+             */
+            void interpolateCubic(Policy *const source_y,
+                                  Policy *destination_y);
+
+            /**
+             * Increment number of sampling points for policy
+             */
+            void increaseSplinePoints();
+
+            /**
+             * Randomly select two policies and return the one with higher fitness
+             * @return an iterator from 'ranked_policies_' map
+             */
+            std::map<double, RLPower::PolicyPtr>::iterator binarySelection();
+
+            /**
+             * Extracts the value of the current_policy in x=time using linear
+             * interpolation
+             *
+             * Writes the output in output_vector
+             */
+            void generateOutput(const double time,
+                                double *output_vector);
+
+            PolicyPtr current_policy_ = NULL; // Pointer to the current policy
+            PolicyPtr interpolation_cache_ = NULL; // Pointer to the interpolated current_policy_ (default 100 points)
+            EvaluatorPtr evaluator_ = NULL; // Pointer to the fitness evaluator
+
+            unsigned int generation_counter_; // Number of current generation
+            unsigned int interpolation_spline_size_; // Number of 'interpolation_cache_' sample points
+            unsigned int max_ranked_policies_; // Maximal number of stored ranked policies
+            unsigned int max_evaluations_; // Maximal number of evaluations
+            unsigned int n_actuators_; // Number of actuators
+            unsigned int n_sensors_; // Number of sensors
+            unsigned int source_y_size_; //
+            unsigned int step_rate_; //
+            unsigned int update_step_; // Number of evaluations after which sampling size increases
+
+            double cycle_start_time_;
+            double evaluation_rate_;
+            double noise_sigma_; // Noise in generatePolicy() function
+            double sigma_tau_correction_; // Tau deviation for self-adaptive sigma
+            double start_eval_time_;
+
+            std::string robot_name_; // Name of the robot
+            std::string algorithm_type_; // Type of the used algorithm
+            std::string policy_load_path_; // Load path for previously saved policies
+            std::map<double, PolicyPtr, std::greater<double>> ranked_policies_; // Container for best ranked policies
+        };
+
+    }
+}
+
+#endif //REVOLVE_BRAIN_SPLINE_CONTROLLER_H
\ No newline at end of file
diff --git a/cpp/neat/accneat/src/neattypes.h b/cpp/neat/accneat/src/neattypes.h
index 116e89c..d76a84f 100644
--- a/cpp/neat/accneat/src/neattypes.h
+++ b/cpp/neat/accneat/src/neattypes.h
@@ -19,7 +19,10 @@ namespace NEAT {
         NT_BIAS = 0,
         NT_SENSOR = 1,
         NT_OUTPUT = 2,
-        NT_HIDDEN = 3
+        NT_HIDDEN = 3,
+	NT_SIMPLE = 4,
+	NT_SIGMOID = 5,
+	NT_DIFFERENTIAL_CPG = 6
     };
 
     struct OrganismEvaluation {
