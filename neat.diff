diff --git a/cpp/CMakeLists.txt b/cpp/CMakeLists.txt
index 2557f7c..e63f4a2 100644
--- a/cpp/CMakeLists.txt
+++ b/cpp/CMakeLists.txt
@@ -5,7 +5,7 @@ if ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang" OR CMAKE_COMPILER_IS_GNUCXX)
     include(CheckCXXCompilerFlag)
     check_cxx_compiler_flag(--std=c++11 SUPPORTS_STD_CXX11)
     if(SUPPORTS_STD_CXX11)
-        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} --std=c++11")
+        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} --std=c++11 -g")
         set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} --std=c++11")
     else()
         message(FATAL_ERROR "Compiler does not support --std=c++11")
@@ -52,7 +52,8 @@ file(GLOB_RECURSE BRAIN_SRCS
         brain/supg/supgneuron.cpp
         brain/supg/supggenomemanager.cpp
         neat/asyncneat.cpp
-        neat/neatevaluation.cpp)
+        neat/neatevaluation.cpp
+        brain/basic_neat_brain.cpp)
 
 # Compiling ####################################################################
 add_library(revolve-brain-static STATIC ${BRAIN_SRCS})
diff --git a/cpp/brain/basic_neat_brain.cpp b/cpp/brain/basic_neat_brain.cpp
new file mode 100644
index 0000000..2761461
--- /dev/null
+++ b/cpp/brain/basic_neat_brain.cpp
@@ -0,0 +1,87 @@
+#include "basic_neat_brain.h"
+#include "neat/asyncneat.h"
+#include <sstream>
+#include <stdexcept>
+#include <limits>
+#include <iomanip>
+#include <string>
+#include <ctime>
+
+using namespace revolve::brain;
+
+
+BasicBrain::BasicBrain(EvaluatorPtr evaluator,
+                     const std::vector< ActuatorPtr >& actuators,
+                     const std::vector< SensorPtr >& sensors)
+  : evaluator(evaluator)
+  , start_eval_time(std::numeric_limits< double >::lowest())
+  , generation_counter(0)
+  , current_evalaution(NULL)
+
+{
+    unsigned int p = 0;
+    std::cout<<"sensor->sensorId()"<<std::endl;
+    for (auto sensor : sensors) {
+        std::cout << "sensor: " << sensor->sensorId() << "(inputs: " << sensor->inputs() << ")" << std::endl;
+        p += sensor->inputs();
+    }
+    std::cout<<"END sensor->sensorId()"<<std::endl;
+    n_inputs = p;
+
+    p = 0;
+    for (auto actuator : actuators) {
+        p += actuator->outputs();
+    }
+    n_outputs = p;
+    this->init_async_neat();
+    std::cout << "brain initailized\n";
+}
+
+void BasicBrain::init_async_neat() {
+    AsyncNeat::Init();
+    unsigned long populationSize = 10;
+    NEAT::GeneticSearchType geneticSearchType = NEAT::GeneticSearchType::PHASED;
+
+
+    AsyncNeat::SetPopulationSize(populationSize); // 10 - 25 - 50 - 75 - 100 - 1000
+    AsyncNeat::SetSearchType(geneticSearchType);
+    std::unique_ptr< AsyncNeat > neat(new AsyncNeat(
+        n_inputs,
+        n_outputs,
+        std::time(0)
+    ));
+
+    this->neat = std::move(neat);
+}
+
+
+void BasicBrain::update(const std::vector< ActuatorPtr >& actuators,
+                       const std::vector< SensorPtr >& sensors,
+                       double t, double step)
+{
+    this->update<std::vector<ActuatorPtr>, std::vector<SensorPtr>>(actuators, sensors, t, step);
+}
+
+double BasicBrain::getFitness()
+{
+    //Calculate fitness for current policy
+    double fitness = evaluator->fitness();
+    std::cout << "Evaluating gait, fitness = " << fitness << std::endl;
+    return fitness;
+}
+
+void BasicBrain::nextBrain()
+{
+    bool init_supgs;
+    if (!current_evalaution) {
+        // first evaluation
+        init_supgs = true;
+    } else {
+        // normal change of evaluation
+        init_supgs = false;
+        current_evalaution->finish(getFitness());
+    }
+
+    current_evalaution = neat->getEvaluation();
+    cppn = current_evalaution->getOrganism()->net.get();
+}
diff --git a/cpp/brain/basic_neat_brain.h b/cpp/brain/basic_neat_brain.h
new file mode 100644
index 0000000..69abfdc
--- /dev/null
+++ b/cpp/brain/basic_neat_brain.h
@@ -0,0 +1,96 @@
+#ifndef REVOLVE_BRAIN_BASIC_NEAT_BRAIN_H
+#define REVOLVE_BRAIN_BASIC_NEAT_BRAIN_H
+
+#include "brain.h"
+#include "neat/asyncneat.h"
+#include "evaluator.h"
+#include "split_cpg/extended_neural_network_controller.h"
+
+#include <vector>
+#include <memory>
+#include <iostream>
+
+namespace revolve {
+namespace brain {
+
+class BasicBrain : public Brain
+{
+//METHODS
+public:
+    BasicBrain(EvaluatorPtr evaluator,
+              const std::vector< ActuatorPtr >& actuators,
+              const std::vector< SensorPtr >& sensors);
+    ~BasicBrain() {}
+
+    virtual void update(const std::vector< ActuatorPtr >& actuators,
+                        const std::vector< SensorPtr >& sensors,
+                        double t, double step) override;
+
+protected:
+
+    template<typename ActuatorContainer, typename SensorContainer>
+    void update(const ActuatorContainer &actuators,
+                const SensorContainer &sensors,
+                double t,
+                double step)
+    {
+        // Evaluate policy on certain time limit
+        if ((t-start_eval_time) > BasicBrain::FREQUENCY_RATE || firstcall) {
+	    firstcall = false;
+            // check if to stop the experiment. Negative value for MAX_EVALUATIONS will never stop the experiment
+            if (BasicBrain::MAX_EVALUATIONS > 0 && generation_counter > BasicBrain::MAX_EVALUATIONS) {
+                std::cout << "Max Evaluations (" << BasicBrain::MAX_EVALUATIONS << ") reached. stopping now." << std::endl;
+                std::exit(0);
+            }
+            generation_counter++;
+            std::cout << "################# EVALUATING NEW BRAIN !!!!!!!!!!!!!!!!!!!!!!!!! (generation " << generation_counter << " )" << std::endl;
+            this->nextBrain();
+            start_eval_time = t;
+            evaluator->start();
+        }
+	cppn->update(actuators, sensors, t, step);
+    }
+
+    void init_async_neat();
+
+private:
+    double getFitness();
+    void nextBrain();
+private:
+    unsigned int n_inputs;
+    unsigned int n_outputs;
+    std::unique_ptr<AsyncNeat> neat;
+    EvaluatorPtr evaluator;
+    double start_eval_time;
+    unsigned int generation_counter;
+    std::shared_ptr< NeatEvaluation > current_evalaution;
+    ExtNNController *cppn;
+    bool firstcall = true;
+    /**
+     * Number of evaluations before the program quits. Usefull to do long run
+     * tests. If negative (default value), it will never stop.
+     *
+     * Takes value from env variable SUPG_MAX_EVALUATIONS.
+     * Default value -1
+     */
+    const long MAX_EVALUATIONS= -1; // max number of evaluations
+    /**
+     * How long should an evaluation lasts (in seconds)
+     *
+     * Takes value from env variable SUPG_FREQUENCY_RATE
+     * Default value 30 seconds
+     */
+    const double FREQUENCY_RATE= 30; // seconds
+    /**
+     * How long should the supg timer cicle be (in seconds)
+     *
+     * Takes value from env variable SUPG_CYCLE_LENGTH
+     * Default value 5 seconds
+     */
+    const double CYCLE_LENGTH = 5; // seconds
+};
+
+}
+}
+
+#endif // REVOLVE_BRAIN_BASIC_NEAT_BRAIN_H
diff --git a/cpp/brain/extnn/extended_neural_network.cpp b/cpp/brain/extnn/extended_neural_network.cpp
index 0c5ef05..22f87e2 100644
--- a/cpp/brain/extnn/extended_neural_network.cpp
+++ b/cpp/brain/extnn/extended_neural_network.cpp
@@ -31,7 +31,6 @@ ExtendedNeuralNetwork::ExtendedNeuralNetwork(std::string modelName,
 	numHiddenNeurons_ = Config.numHiddenNeurons_;
 }
 
-
 ExtendedNeuralNetwork::~ExtendedNeuralNetwork()
 {
 	delete [] inputs_;
diff --git a/cpp/brain/extnn/extended_neural_network.h b/cpp/brain/extnn/extended_neural_network.h
index 410a6fd..516b5b7 100644
--- a/cpp/brain/extnn/extended_neural_network.h
+++ b/cpp/brain/extnn/extended_neural_network.h
@@ -45,6 +45,7 @@ public:
 			      const std::vector< ActuatorPtr > &actuators ,
 			      const std::vector< SensorPtr > &sensors);
 
+	ExtendedNeuralNetwork() {};
 	virtual ~ExtendedNeuralNetwork();
 
 	/**
diff --git a/cpp/brain/split_cpg/converting_split_brain.h b/cpp/brain/split_cpg/converting_split_brain.h
index ae7126a..378f546 100644
--- a/cpp/brain/split_cpg/converting_split_brain.h
+++ b/cpp/brain/split_cpg/converting_split_brain.h
@@ -27,10 +27,12 @@ public:
                         double t,
                         double step) 
     {
-	if ((t - start_eval_time_) > evaluation_rate_ && generation_counter_ < max_evaluations_) {
+	if (start_eval_time_ == 0 || (t - start_eval_time_) > evaluation_rate_ && generation_counter_ < max_evaluations_) {
 	    double fitness = evaluator_->fitness();
-	    std::cout << fitness << std::endl;
-	    this->learner->reportFitness("test", convertForLearner_(this->controller->getGenome()), fitness);
+	    if(start_eval_time_ != 0) {
+		std::cout << fitness << std::endl;
+		this->learner->reportFitness("test", convertForLearner_(this->controller->getGenome()), fitness);
+	    }
 	    this->controller->setGenome(convertForController_(this->learner->getNewGenome("test")));
 	    start_eval_time_ = t;
 	    evaluator_->start();
diff --git a/cpp/brain/split_cpg/extended_neural_network_controller.cpp b/cpp/brain/split_cpg/extended_neural_network_controller.cpp
index 753fc0a..670cba2 100644
--- a/cpp/brain/split_cpg/extended_neural_network_controller.cpp
+++ b/cpp/brain/split_cpg/extended_neural_network_controller.cpp
@@ -9,14 +9,10 @@ namespace brain {
 
 
 ExtNNController::ExtNNController(std::string modelName,
-					     ExtNNConfig Config,
-					     EvaluatorPtr evaluator,
-					     const std::vector< ActuatorPtr > & actuators,
-					     const std::vector< SensorPtr > & sensors)
+					     ExtNNConfig Config)
 {
 	modelName_ = modelName;
-	
-	evaluator_ = evaluator;
+
 	inputs_ = Config.inputs_;
 	outputs_ = Config.outputs_;
 	allNeurons_ = Config.allNeurons_;
@@ -32,6 +28,26 @@ ExtNNController::ExtNNController(std::string modelName,
 	numHiddenNeurons_ = Config.numHiddenNeurons_;
 }
 
+void ExtNNController::configure(std::string modelName,
+				ExtNNConfig Config)
+{
+	modelName_ = modelName;
+
+	inputs_ = Config.inputs_;
+	outputs_ = Config.outputs_;
+	allNeurons_ = Config.allNeurons_;
+	inputNeurons_ = Config.inputNeurons_;
+	outputNeurons_ = Config.outputNeurons_;
+	hiddenNeurons_ = Config.hiddenNeurons_;
+	outputPositionMap_ = Config.outputPositionMap_;
+	inputPositionMap_ = Config.inputPositionMap_;
+	idToNeuron_ = Config.idToNeuron_;
+	connections_ = Config.connections_;
+	numInputNeurons_ = Config.numInputNeurons_;
+	numOutputNeurons_ = Config.numOutputNeurons_;
+	numHiddenNeurons_ = Config.numHiddenNeurons_;
+	
+}
 
 ExtNNController::~ExtNNController()
 {
@@ -138,8 +154,6 @@ void ExtNNController::update(const std::vector<ActuatorPtr>& actuators,
 				   double t,
 				   double step) 
 {
-//   	std::cout << "yay! \n";
-	//boost::mutex::scoped_lock lock(networkMutex_);
 
 	// Read sensor data into the input buffer
 	unsigned int p = 0;
@@ -160,8 +174,7 @@ void ExtNNController::update(const std::vector<ActuatorPtr>& actuators,
 		(*it)->Update(t);
 	}
 
-
-	// Flip states of all neurons
+	// Flip states of all neuron
 	for (auto it = allNeurons_.begin(); it != allNeurons_.end(); ++it) {
 		(*it)->FlipState();
 	}
@@ -177,7 +190,6 @@ void ExtNNController::update(const std::vector<ActuatorPtr>& actuators,
 	}
 
 	// debF.close();
-	
 	// Send new signals to the actuators
 	p = 0;
 	for (auto actuator: actuators) {
diff --git a/cpp/brain/split_cpg/extended_neural_network_controller.h b/cpp/brain/split_cpg/extended_neural_network_controller.h
index 396dfc5..e6bf6a9 100644
--- a/cpp/brain/split_cpg/extended_neural_network_controller.h
+++ b/cpp/brain/split_cpg/extended_neural_network_controller.h
@@ -34,17 +34,14 @@ public:
 	 * Constructor for a neural network including neurons that are of a different type than the usual ones.
 	 * @param modelName: name of the model
 	 * @param Config: configuration file
-	 * @param evaluator: pointer to the evaluator that is used
-	 * @param actuators: vector list of robot's actuators
-	 * @param sensors: vector list of robot's sensors
 	 * @return pointer to the neural network
 	 */
 	ExtNNController(std::string modelName,
-			      ExtNNConfig Config,
-			      EvaluatorPtr evaluator,
-			      const std::vector< ActuatorPtr > &actuators ,
-			      const std::vector< SensorPtr > &sensors);
-
+			      ExtNNConfig Config);
+	ExtNNController() {};
+	
+	void configure(std::string modelName,
+			      ExtNNConfig Config);
 	virtual ~ExtNNController();
 
 	/**
@@ -58,7 +55,7 @@ public:
 			    const std::vector< SensorPtr > &sensors,
 			    double t,
 			    double step);
-
+	unsigned int population_index; //TODO:: implement
 protected:
 
 	// Mutex for updating the network
@@ -113,7 +110,6 @@ protected:
 
 	std::string modelName_; //name of the robot
 	
-	EvaluatorPtr evaluator_ = NULL; //pointer to the evaluator that is used
 
 	double * inputs_;    // buffer of input values from the sensors
 	double * outputs_;     // buffer of output values for the actuators
diff --git a/cpp/brain/split_cpg/spline_controller.h b/cpp/brain/split_cpg/spline_controller.h
new file mode 100644
index 0000000..478a799
--- /dev/null
+++ b/cpp/brain/split_cpg/spline_controller.h
@@ -0,0 +1,201 @@
+//
+// Created by Milan Jelisavcic on 28/03/16.
+//
+
+#ifndef REVOLVE_BRAIN_SPLINE_CONTROLLER_H
+#define REVOLVE_BRAIN_SPLINE_CONTROLLER_H
+
+#include "controller.h"
+
+#include <cmath>
+#include <string>
+
+
+namespace revolve {
+    namespace brain {
+
+//    typedef std::vector<double> Spline;
+//    typedef std::vector<Spline *> Policy;
+
+        class SplineController : public revolve::brain::Controller<std::vector<std::vector<double>>> {
+	protected:
+	    struct Config;
+        public:
+            typedef std::vector<double> Spline;
+            typedef std::vector<Spline> Policy;
+            typedef std::shared_ptr<Policy> PolicyPtr;
+            /**
+             * The RLPower constructor reads out configuration file, deretmines which algorithm type to apply and
+             * initialises new policy.
+             * @param modelName: name of a robot
+             * @param brain: configuration file
+             * @param evaluator: pointer to fitness evaluatior
+             * @param n_actuators: number of actuators
+             * @param n_sensors: number of sensors
+             * @return pointer to the RLPower class object
+             */
+            SplineController(std::string modelName,
+                    Config brain,
+                    EvaluatorPtr evaluator,
+                    unsigned int n_actuators,
+                    unsigned int n_sensors);
+
+            virtual ~SplineController();
+
+            /**
+             * Method for updating sensors readings, actuators positions, ranked list of policies and generating new policy
+             * @param actuators: vector list of robot's actuators
+             * @param sensors: vector list of robot's sensors
+             * @param t:
+             * @param step:
+             */
+            virtual void update(const std::vector<ActuatorPtr> &actuators,
+                                const std::vector<SensorPtr> &sensors,
+                                double t,
+                                double step);
+	    /**
+	    * Get method for the genome
+	    * @return current genome
+	    */
+	    virtual G getGenome();
+	    
+	    /**
+	    * Set method for the genome
+	    * @param newGenome: new genome to use instead of the old one
+	    */
+	    virtual void setGenome(G newGenome);
+      
+        protected:
+//        /**
+//         * Request handler to modify the neural network
+//         */
+//        void modify(ConstModifyNeuralNetworkPtr &req);
+//
+//        boost::mutex networkMutex_; // Mutex for stepping / updating the network
+
+            /**
+             * Ranked list of used splines
+             */
+            class PolicySave {
+            public:
+                PolicyPtr policy_;
+                double fitness_;
+
+                PolicySave(double fitness, PolicyPtr &p) :
+                        policy_(p),
+                        fitness_(fitness) {}
+
+                bool operator>(const PolicySave &ps) const {
+                    return this->fitness_ > ps.fitness_;
+                }
+            };
+
+            static const unsigned int MAX_EVALUATIONS;// = 1000; // max number of evaluations
+            static const unsigned int MAX_RANKED_POLICIES;// = 10; // max length of policies vector
+            static const unsigned int INTERPOLATION_CACHE_SIZE;// = 100; // number of data points for the interpolation cache
+            static const unsigned int INITIAL_SPLINE_SIZE;// = 3; // number of initially sampled spline points
+            static const unsigned int UPDATE_STEP;// = 100; // after # generations, it increases the number of spline points
+            static const double EVALUATION_RATE;// = 30.0; // evaluation time for each policy
+            static const double SIGMA_START_VALUE;// = 0.8; // starting value for sigma
+            static const double SIGMA_TAU_CORRECTION;// = 0.2;
+
+            static const double CYCLE_LENGTH;// = 5; // seconds
+            static const double SIGMA_DECAY_SQUARED;// = 0.98; // sigma decay
+
+            template<typename ActuatorContainer, typename SensorContainer>
+            void update(const ActuatorContainer &actuators,
+                        const SensorContainer &sensors,
+                        double t,
+                        double step) {
+
+                // generate outputs
+                double *output_vector = new double[n_actuators_];
+                this->generateOutput(t, output_vector);
+
+                // Send new signals to the actuators
+                unsigned int p = 0;
+                for (auto actuator: actuators) {
+                    actuator->update(&output_vector[p], step);
+                    p += actuator->outputs();
+                }
+
+                delete[] output_vector;
+            }
+
+            struct Config {
+                std::string algorithm_type;
+                unsigned int evaluation_rate;
+                unsigned int interpolation_spline_size;
+                unsigned int max_evaluations;
+                unsigned int max_ranked_policies;
+                double noise_sigma;
+                double sigma_tau_correction;
+                unsigned int source_y_size;
+                unsigned int update_step;
+                std::string policy_load_path;
+            };
+
+        private:
+
+            /**
+             * Generate cache policy
+             */
+            void generateCache();
+            /**
+             * Generate interpolated spline based on number of sampled control points in 'source_y'
+             * @param source_y: set of control points over which interpolation is generated
+             * @param destination_y: set of interpolated control points (default 100 points)
+             */
+            void interpolateCubic(Policy *const source_y,
+                                  Policy *destination_y);
+
+            /**
+             * Increment number of sampling points for policy
+             */
+            void increaseSplinePoints();
+
+            /**
+             * Randomly select two policies and return the one with higher fitness
+             * @return an iterator from 'ranked_policies_' map
+             */
+            std::map<double, RLPower::PolicyPtr>::iterator binarySelection();
+
+            /**
+             * Extracts the value of the current_policy in x=time using linear
+             * interpolation
+             *
+             * Writes the output in output_vector
+             */
+            void generateOutput(const double time,
+                                double *output_vector);
+
+            PolicyPtr current_policy_ = NULL; // Pointer to the current policy
+            PolicyPtr interpolation_cache_ = NULL; // Pointer to the interpolated current_policy_ (default 100 points)
+            EvaluatorPtr evaluator_ = NULL; // Pointer to the fitness evaluator
+
+            unsigned int generation_counter_; // Number of current generation
+            unsigned int interpolation_spline_size_; // Number of 'interpolation_cache_' sample points
+            unsigned int max_ranked_policies_; // Maximal number of stored ranked policies
+            unsigned int max_evaluations_; // Maximal number of evaluations
+            unsigned int n_actuators_; // Number of actuators
+            unsigned int n_sensors_; // Number of sensors
+            unsigned int source_y_size_; //
+            unsigned int step_rate_; //
+            unsigned int update_step_; // Number of evaluations after which sampling size increases
+
+            double cycle_start_time_;
+            double evaluation_rate_;
+            double noise_sigma_; // Noise in generatePolicy() function
+            double sigma_tau_correction_; // Tau deviation for self-adaptive sigma
+            double start_eval_time_;
+
+            std::string robot_name_; // Name of the robot
+            std::string algorithm_type_; // Type of the used algorithm
+            std::string policy_load_path_; // Load path for previously saved policies
+            std::map<double, PolicyPtr, std::greater<double>> ranked_policies_; // Container for best ranked policies
+        };
+
+    }
+}
+
+#endif //REVOLVE_BRAIN_SPLINE_CONTROLLER_H
\ No newline at end of file
diff --git a/cpp/neat/accneat/CMakeLists.txt b/cpp/neat/accneat/CMakeLists.txt
index c818d52..2a6fb61 100644
--- a/cpp/neat/accneat/CMakeLists.txt
+++ b/cpp/neat/accneat/CMakeLists.txt
@@ -11,14 +11,15 @@ ELSE ()
 ENDIF ()
 
 #TODO enable cuda
+include_directories("../../")
 
 SET(accneat_sources
-        src/experiments/experiment.cpp
-        src/experiments/maze/maze.cpp
-        src/experiments/static/cfg.cpp
-        src/experiments/static/regex.cpp
-        src/experiments/static/sequence.cpp
-        src/experiments/static/xor.cpp
+#         src/experiments/experiment.cpp
+#         src/experiments/maze/maze.cpp
+#         src/experiments/static/cfg.cpp
+#         src/experiments/static/regex.cpp
+#         src/experiments/static/sequence.cpp
+#         src/experiments/static/xor.cpp
         src/genomemanager.cpp
         src/innovgenome/innovation.cpp
         src/innovgenome/innovgenome.cpp
@@ -45,14 +46,14 @@ SET(accneat_sources
         src/util/util.cpp
         )
 
-SET(accneat_cxx_sources
-        src/experiments/static/staticevaluator.cxx
-        src/experiments/maze/mazeevaluator.cxx
-        )
+# SET(accneat_cxx_sources
+#         src/experiments/static/staticevaluator.cxx
+#         src/experiments/maze/mazeevaluator.cxx
+#         )
 
 INCLUDE_DIRECTORIES("src")
 
-add_library(accneat ${accneat_sources} ${accneat_cxx_sources})
+add_library(accneat ${accneat_sources} )#${accneat_cxx_sources})
 
 IF (NOT ${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
     target_compile_definitions(accneat PRIVATE WITH_OPENMP)
diff --git a/cpp/neat/accneat/src/innovgenome/innovgenome.cpp b/cpp/neat/accneat/src/innovgenome/innovgenome.cpp
index ba25952..0f966d5 100644
--- a/cpp/neat/accneat/src/innovgenome/innovgenome.cpp
+++ b/cpp/neat/accneat/src/innovgenome/innovgenome.cpp
@@ -20,6 +20,8 @@
 #include <assert.h>
 #include <cstring>
 
+#include "brain/extnn/extended_neural_network.h"
+
 using namespace NEAT;
 using namespace std;
 
@@ -41,7 +43,7 @@ InnovGenome::InnovGenome(rng_t rng_,
     : InnovGenome() {
 
     rng = rng_;
-
+    ntraits = noutputs + nhidden;
     for(size_t i = 0; i < ntraits; i++) {
         traits.emplace_back(i + 1,
                             rng.prob(),
@@ -59,21 +61,24 @@ InnovGenome::InnovGenome(rng_t rng_,
         int node_id = 1;
 
         //Bias node
-        add_node(nodes, InnovNodeGene(NT_BIAS, node_id++));
+        add_node(nodes, InnovNodeGene(NT_HIDDEN, node_id++, BIAS));
+	nodes[nodes.size()-1].set_trait_id(node_id);
 
         //Sensor nodes
         for(size_t i = 0; i < ninputs; i++) {
-            add_node(nodes, InnovNodeGene(NT_SENSOR, node_id++));
+            add_node(nodes, InnovNodeGene(NT_SENSOR, node_id++, INPUT));
         }
 
         //Output nodes
         for(size_t i = 0; i < noutputs; i++) {
-            add_node(nodes, InnovNodeGene(NT_OUTPUT, node_id++));
+            add_node(nodes, InnovNodeGene(NT_OUTPUT, node_id++, SIGMOID));
+	    nodes[nodes.size()-1].set_trait_id(node_id);
         }
 
         //Hidden nodes
         for(size_t i = 0; i < nhidden; i++) {
-            add_node(nodes, InnovNodeGene(NT_HIDDEN, node_id++));
+            add_node(nodes, InnovNodeGene(NT_HIDDEN, node_id++, SIGMOID));
+	    nodes[nodes.size()-1].set_trait_id(node_id);
         }
     }
 
@@ -166,23 +171,7 @@ Genome::Stats InnovGenome::get_stats() {
     return {nodes.size(), links.size()};
 }
 
-void InnovGenome::print(std::ostream &out) {
-    out<<"genomestart "<<genome_id<<std::endl;
 
-    //Output the traits
-    for(auto &t: traits)
-        t.print_to_file(out);
-
-    //Output the nodes
-    for(auto &n: nodes)
-        n.print_to_file(out);
-
-    //Output the genes
-    for(auto &g: links)
-        g.print_to_file(out);
-
-    out << "genomeend " << genome_id << std::endl;
-}
 
 int InnovGenome::get_last_node_id() {
     return nodes.back().node_id + 1;
@@ -201,7 +190,6 @@ void InnovGenome::duplicate_into(InnovGenome *offspring) const {
 InnovGenome &InnovGenome::operator=(const InnovGenome &other) {
     rng = other.rng;
     genome_id = other.genome_id;
-    traits = other.traits;
     nodes = other.nodes;
     links = other.links;
     return *this;
@@ -211,32 +199,6 @@ void InnovGenome::mutate_random_trait() {
     rng.element(traits).mutate(rng);
 }
 
-void InnovGenome::mutate_link_trait(int times) {
-    for(int i = 0; i < times; i++) {
-        int trait_id = 1 + rng.index(traits);
-        InnovLinkGene &gene = rng.element(links);
-
-        if(!gene.frozen) {
-            gene.set_trait_id(trait_id);
-        }
-    }
-}
-
-void InnovGenome::mutate_node_trait(int times) {
-    for(int i = 0; i < times; i++) {
-        int trait_id = 1 + rng.index(traits);
-        InnovNodeGene &node = rng.element(nodes);
-
-        if(!node.frozen) {
-            node.set_trait_id(trait_id);
-        }
-    }
-
-    //TRACK INNOVATION! - possible future use
-    //for any gene involving the mutated node, perturb that gene's
-    //mutation number
-}
-
 void InnovGenome::mutate_link_weights(real_t power,real_t rate,mutator mut_type) {
     //Go through all the InnovLinkGenes and perturb their link's weights
 
@@ -310,235 +272,6 @@ void InnovGenome::mutate_link_weights(real_t power,real_t rate,mutator mut_type)
     } //end for loop
 }
 
-void InnovGenome::mutate_toggle_enable(int times) {
-    for(int i = 0; i < times; i++) {
-        InnovLinkGene &gene = rng.element(links);
-
-        if(!gene.enable) {
-            gene.enable = true;
-        } else {
-            //We need to make sure that another gene connects out of the in-node
-            //Because if not a section of network will break off and become isolated
-            bool found = false;
-            for(InnovLinkGene &checkgene: links) {
-                if( (checkgene.in_node_id() == gene.in_node_id())
-                    && checkgene.enable
-                    && (checkgene.innovation_num != gene.innovation_num) ) {
-                    found = true;
-                    break;
-                }
-            }
-
-            //Disable the gene if it's safe to do so
-            if(found)
-                gene.enable = false;
-        }
-    }
-}
-
-void InnovGenome::mutate_gene_reenable() {
-    //Search for a disabled gene
-    for(InnovLinkGene &g: links) {
-        if(!g.enable) {
-            g.enable = true;
-            break;
-        }
-    }
-}
-
-bool InnovGenome::mutate_add_node(CreateInnovationFunc create_innov,
-                                  bool delete_split_link) {
-    InnovLinkGene *splitlink = nullptr;
-    {
-        for(int i = 0; !splitlink && i < 20; i++) {
-            InnovLinkGene &g = rng.element(links);
-            //If either the link is disabled, or it has a bias input, try again
-            if( g.enable && get_node(g.in_node_id())->type != NT_BIAS ) {
-                splitlink = &g;
-            }
-        }
-        //We couldn't find anything, so say goodbye!
-        if (!splitlink) {
-            return false;
-        }
-    }
-
-    InnovationId innov_id(splitlink->in_node_id(),
-                          splitlink->out_node_id(),
-                          splitlink->innovation_num);
-    InnovationParms innov_parms;
-
-    auto innov_apply = [this, delete_split_link, splitlink] (const Innovation *innov) {
-
-        InnovNodeGene newnode(NT_HIDDEN, innov->newnode_id);
-
-        InnovLinkGene newlink1(splitlink->trait_id(),
-                               1.0,
-                               innov->id.node_in_id,
-                               innov->newnode_id,
-                               splitlink->is_recurrent(),
-                               innov->innovation_num1,
-                               0);
-
-        InnovLinkGene newlink2(splitlink->trait_id(),
-                               splitlink->weight(),
-                               innov->newnode_id,
-                               innov->id.node_out_id,
-                               false,
-                               innov->innovation_num2,
-                               0);
-
-        if(delete_split_link) {
-            delete_link(splitlink);
-        } else {
-            splitlink->enable = false;
-        }
-
-        add_link(this->links, newlink1);
-        add_link(this->links, newlink2);
-        add_node(this->nodes, newnode);
-    };
-
-    create_innov(innov_id, innov_parms, innov_apply);
-
-    return true;
-}
-
-void InnovGenome::mutate_delete_node() {
-    size_t first_non_io;
-    for(first_non_io = 0; first_non_io < nodes.size(); first_non_io++) {
-        if( nodes[first_non_io].type == NT_HIDDEN ) {
-            break;
-        }
-    }
-
-    //Don't delete if only 0 or 1 hidden nodes
-    if(first_non_io >= (nodes.size()-1)) {
-        return;
-    }
-
-    size_t node_index = rng.index(nodes, first_non_io);
-    InnovNodeGene node = nodes[node_index];
-    assert(node.type == NT_HIDDEN);
-
-    nodes.erase(nodes.begin() + node_index);
-
-    //todo: we should have a way to look up links by in/out id
-    auto it_end = std::remove_if(links.begin(), links.end(),
-                                 [&node] (const InnovLinkGene &link) {
-                                     return link.in_node_id() == node.node_id
-                                     || link.out_node_id() == node.node_id;
-                                 });
-
-    links.resize(it_end - links.begin());
-}
-
-void InnovGenome::mutate_delete_link() {
-    if(links.size() <= 1)
-        return;
-
-    size_t link_index = rng.index(links);
-    InnovLinkGene link = links[link_index];
-    links.erase(links.begin() + link_index);
-
-    delete_if_orphaned_hidden_node(link.in_node_id());
-    delete_if_orphaned_hidden_node(link.out_node_id());
-}
-
-bool InnovGenome::mutate_add_link(CreateInnovationFunc create_innov,
-                                  int tries) {
-    InnovLinkGene *recur_checker_buf[links.size()];
-    RecurrencyChecker recur_checker(nodes.size(), links, recur_checker_buf);
-
-    InnovNodeGene *in_node = nullptr; //Pointers to the nodes
-    InnovNodeGene *out_node = nullptr; //Pointers to the nodes
-
-    //Decide whether to make this recurrent
-    bool do_recur = rng.prob() < env->recur_only_prob;
-
-    // Try to find nodes for link.
-    {
-        bool found_nodes = false;
-
-        //Find the first non-sensor so that the to-node won't look at sensors as
-        //possible destinations
-        int first_nonsensor = 0;
-        for(; is_input(nodes[first_nonsensor].get_type()); first_nonsensor++) {
-        }
-
-        for(int trycount = 0; !found_nodes && (trycount < tries); trycount++) {
-            //Here is the recurrent finder loop- it is done separately
-            if(do_recur) {
-                //Some of the time try to make a recur loop
-                // todo: make this an NE parm?
-                if (rng.prob() > 0.5) {
-                    in_node = &rng.element(nodes, first_nonsensor);
-                    out_node = in_node;
-                }
-                else {
-                    //Choose random nodenums
-                    in_node = &rng.element(nodes);
-                    out_node = &rng.element(nodes, first_nonsensor);
-                }
-            } else {
-                //Choose random nodenums
-                in_node = &rng.element(nodes);
-                out_node = &rng.element(nodes, first_nonsensor);
-            }
-
-            InnovLinkGene *existing_link = find_link(in_node->node_id, out_node->node_id, do_recur);
-            if(existing_link != nullptr) {
-                if( env->mutate_add_link_reenables ) {
-                    existing_link->enable = true;
-                    return true;
-                }
-            } else if(do_recur == recur_checker.is_recur(in_node->node_id,
-                                                         out_node->node_id)) {
-                found_nodes = true;
-            }
-        }
-
-        assert( !is_input(out_node->type) );
-
-        //Continue only if an open link was found
-        if(!found_nodes) {
-            return false;
-        }
-    }
-
-    // Create the gene.
-    {
-        InnovationId innov_id(in_node->node_id,
-                              out_node->node_id,
-                              do_recur);
-
-        //These two values may or may not take effect in the new innovation.
-        //It depends on whether this genome is the first to create the innovation,
-        //but it's impossible to know at this point who is first.
-        int trait_id = 1 + rng.index(traits);
-        real_t newweight = rng.posneg() * rng.prob() * 1.0;
-
-        InnovationParms innov_parms(newweight, trait_id);
-
-        auto innov_apply = [this] (const Innovation *innov) {
-
-            InnovLinkGene newlink(innov->parms.new_trait_id,
-                                  innov->parms.new_weight,
-                                  innov->id.node_in_id,
-                                  innov->id.node_out_id,
-                                  innov->id.recur_flag,
-                                  innov->innovation_num1,
-                                  innov->parms.new_weight);
-
-            add_link(this->links, newlink);
-        };
-
-        create_innov(innov_id, innov_parms, innov_apply);
-    }
-
-    return true;
-}
-
 void InnovGenome::add_link(vector<InnovLinkGene> &llist, const InnovLinkGene &l) {
     auto it = std::upper_bound(llist.begin(), llist.end(), l, linklist_cmp);
     llist.insert(it, l);
@@ -555,20 +288,12 @@ void InnovGenome::mate(InnovGenome *genome1,
                        real_t fitness1,
                        real_t fitness2) {
 
-    //Perform mating based on probabilities of differrent mating types
-    if( offspring->rng.prob() < env->mate_multipoint_prob ) {
         InnovGenome::mate_multipoint(genome1,
                                      genome2,
                                      offspring,
                                      fitness1,
                                      fitness2);
-    } else {
-        InnovGenome::mate_multipoint_avg(genome1,
-                                         genome2,
-                                         offspring,
-                                         fitness1,
-                                         fitness2);
-    }
+
 }
 
 // todo: use NodeLookup for newnodes instead of linear search!
@@ -803,259 +528,6 @@ void InnovGenome::mate_multipoint(InnovGenome *genome1,
     }
 }
 
-// todo: use NodeLookup for newnodes instead of linear search!
-void InnovGenome::mate_multipoint_avg(InnovGenome *genome1,
-                                      InnovGenome *genome2,
-                                      InnovGenome *offspring,
-                                      real_t fitness1,
-                                      real_t fitness2) {
-    rng_t &rng = offspring->rng;
-    vector<InnovLinkGene> &links1 = genome1->links;
-    vector<InnovLinkGene> &links2 = genome2->links;
-
-    //The baby InnovGenome will contain these new Traits, InnovNodeGenes, and InnovLinkGenes
-    offspring->reset();
-    vector<Trait> &newtraits = offspring->traits;
-    vector<InnovNodeGene> &newnodes = offspring->nodes;
-    vector<InnovLinkGene> &newlinks = offspring->links;
-
-    vector<InnovLinkGene>::iterator curgene2; //Checking for link duplication
-
-    //iterators for moving through the two parents' links
-    vector<InnovLinkGene>::iterator p1gene;
-    vector<InnovLinkGene>::iterator p2gene;
-    real_t p1innov;  //Innovation numbers for links inside parents' InnovGenomes
-    real_t p2innov;
-    vector<InnovNodeGene>::iterator curnode;  //For checking if InnovNodeGenes exist already
-
-    //This InnovLinkGene is used to hold the average of the two links to be averaged
-    InnovLinkGene avgene(0,0,0,0,0,0,0);
-    InnovLinkGene newgene;
-
-    bool skip;
-
-    bool p1better;  //Designate the better genome
-
-    //First, average the Traits from the 2 parents to form the baby's Traits
-    //It is assumed that trait lists are the same length
-    //In future, could be done differently
-    for(size_t i = 0, n = genome1->traits.size(); i < n; i++) {
-        newtraits.emplace_back(genome1->traits[i], genome2->traits[i]);
-    }
-
-    //NEW 3/17/03 Make sure all sensors and outputs are included
-    for(InnovNodeGene &node: genome1->nodes) {
-        if(node.type != NT_HIDDEN) {
-            add_node(newnodes, node);
-        } else {
-            break;
-        }
-    }
-
-    //Figure out which genome is better
-    //The worse genome should not be allowed to add extra structural baggage
-    //If they are the same, use the smaller one's disjoint and excess genes only
-    if (fitness1>fitness2)
-        p1better=true;
-    else if (fitness1==fitness2) {
-        if (links1.size()<(links2.size()))
-            p1better=true;
-        else p1better=false;
-    }
-    else
-        p1better=false;
-
-
-    //Now move through the InnovLinkGenes of each parent until both genomes end
-    p1gene=links1.begin();
-    p2gene=links2.begin();
-    while(!((p1gene==links1.end()) && (p2gene==(links2).end()))) {
-        ProtoInnovLinkGene protogene;
-
-        avgene.enable=true;  //Default to enabled
-
-        skip=false;
-
-        if (p1gene==links1.end()) {
-            protogene.set_gene(genome2, &*p2gene);
-            ++p2gene;
-
-            if (p1better) skip=true;
-
-        }
-        else if (p2gene==(links2).end()) {
-            protogene.set_gene(genome1, &*p1gene);
-            ++p1gene;
-
-            if (!p1better) skip=true;
-        }
-        else {
-            //Extract current innovation numbers
-            p1innov=p1gene->innovation_num;
-            p2innov=p2gene->innovation_num;
-
-            if (p1innov==p2innov) {
-                protogene.set_gene(nullptr, &avgene);
-
-                //Average them into the avgene
-                if (rng.prob()>0.5) {
-                    avgene.set_trait_id(p1gene->trait_id());
-                } else {
-                    avgene.set_trait_id(p2gene->trait_id());
-                }
-
-                //WEIGHTS AVERAGED HERE
-                avgene.weight() = (p1gene->weight()+p2gene->weight())/2.0;
-
-                if(rng.prob() > 0.5) {
-                    protogene.set_in(genome1->get_node(p1gene->in_node_id()));
-                } else {
-                    protogene.set_in(genome2->get_node(p2gene->in_node_id()));
-                }
-
-                if(rng.prob() > 0.5) {
-                    protogene.set_out(genome1->get_node(p1gene->out_node_id()));
-                } else {
-                    protogene.set_out(genome2->get_node(p2gene->out_node_id()));
-                }
-
-                if (rng.prob()>0.5) avgene.set_recurrent(p1gene->is_recurrent());
-                else avgene.set_recurrent(p2gene->is_recurrent());
-
-                avgene.innovation_num=p1gene->innovation_num;
-                avgene.mutation_num=(p1gene->mutation_num+p2gene->mutation_num)/2.0;
-
-                if (((p1gene->enable)==false)||
-                    ((p2gene->enable)==false))
-                    if (rng.prob()<0.75) avgene.enable=false;
-
-                ++p1gene;
-                ++p2gene;
-            } else if (p1innov<p2innov) {
-                protogene.set_gene(genome1, &*p1gene);
-                ++p1gene;
-
-                if (!p1better) skip=true;
-            } else if (p2innov<p1innov) {
-                protogene.set_gene(genome2, &*p2gene);
-                ++p2gene;
-
-                if (p1better) skip=true;
-            }
-        }
-
-        //Check to see if the chosengene conflicts with an already chosen gene
-        //i.e. do they represent the same link
-        curgene2=newlinks.begin();
-        while ((curgene2!=newlinks.end()))
-
-        {
-
-            if (((curgene2->in_node_id()==protogene.gene()->in_node_id())&&
-                 (curgene2->out_node_id()==protogene.gene()->out_node_id())&&
-                 (curgene2->is_recurrent()== protogene.gene()->is_recurrent()))||
-                ((curgene2->out_node_id()==protogene.gene()->in_node_id())&&
-                 (curgene2->in_node_id()==protogene.gene()->out_node_id())&&
-                 (!(curgene2->is_recurrent()))&&
-                 (!(protogene.gene()->is_recurrent()))     ))
-            {
-                skip=true;
-
-            }
-            ++curgene2;
-        }
-
-        if (!skip) {
-            //Now add the chosengene to the baby
-
-            //Next check for the nodes, add them if not in the baby InnovGenome already
-            InnovNodeGene *inode = protogene.in();
-            InnovNodeGene *onode = protogene.out();
-
-            //Check for inode in the newnodes list
-            InnovNodeGene new_inode;
-            InnovNodeGene new_onode;
-            if (inode->node_id<onode->node_id) {
-
-                //Checking for inode's existence
-                curnode=newnodes.begin();
-                while((curnode!=newnodes.end())&&
-                      (curnode->node_id!=inode->node_id))
-                    ++curnode;
-
-                if (curnode==newnodes.end()) {
-                    //Here we know the node doesn't exist so we have to add it
-                    new_inode = *inode;
-                    add_node(newnodes,new_inode);
-                }
-                else {
-                    new_inode=(*curnode);
-
-                }
-
-                //Checking for onode's existence
-                curnode=newnodes.begin();
-                while((curnode!=newnodes.end())&&
-                      (curnode->node_id!=onode->node_id))
-                    ++curnode;
-                if (curnode==newnodes.end()) {
-                    //Here we know the node doesn't exist so we have to add it
-                    new_onode = *onode;
-
-                    add_node(newnodes,new_onode);
-                }
-                else {
-                    new_onode=(*curnode);
-                }
-            }
-            //If the onode has a higher id than the inode we want to add it first
-            else {
-                //Checking for onode's existence
-                curnode=newnodes.begin();
-                while((curnode!=newnodes.end())&&
-                      (curnode->node_id!=onode->node_id))
-                    ++curnode;
-                if (curnode==newnodes.end()) {
-                    //Here we know the node doesn't exist so we have to add it
-                    new_onode = *onode;
-
-                    add_node(newnodes,new_onode);
-                }
-                else {
-                    new_onode=(*curnode);
-                }
-
-                //Checking for inode's existence
-                curnode=newnodes.begin();
-                while((curnode!=newnodes.end())&&
-                      (curnode->node_id!=inode->node_id))
-                    ++curnode;
-                if (curnode==newnodes.end()) {
-                    //Here we know the node doesn't exist so we have to add it
-                    new_inode = *inode;
-
-                    add_node(newnodes,new_inode);
-                }
-                else {
-                    new_inode=(*curnode);
-
-                }
-
-            } //End InnovNodeGene checking section- InnovNodeGenes are now in new InnovGenome
-
-            //Add the InnovLinkGene
-            newgene = InnovLinkGene(protogene.gene(),
-                                    protogene.gene()->trait_id(),
-                                    new_inode.node_id,
-                                    new_onode.node_id);
-
-            newlinks.push_back(newgene);
-
-        }  //End if which checked for link duplicationb
-
-    }
-}
-
 real_t InnovGenome::compatibility(InnovGenome *g) {
     vector<InnovLinkGene> &links1 = this->links;
     vector<InnovLinkGene> &links2 = g->links;
@@ -1184,6 +656,138 @@ Trait &InnovGenome::get_trait(const InnovLinkGene &gene) {
     return ::get_trait(traits, gene.trait_id());
 }
 
+void InnovGenome::init_phenotype(revolve::brain::ExtNNController::ExtNNConfig &config) {
+    size_t nnodes = nodes.size();
+    assert(nnodes <= NODES_MAX);
+
+    config.numHiddenNeurons_ = 0;
+    config.numInputNeurons_ = 0;
+    config.numOutputNeurons_ = 0;
+    for(size_t i = 0; i < nnodes; i++) {
+        InnovNodeGene &node = nodes[i];
+	std::string neuronId = std::to_string(i);
+	std::map<std::string, double> params;
+	//get parameters from trait of neuron
+	if(traits.size() != 0) {
+	Trait neuronParams = traits[node.get_trait_id()];
+	params["rv:bias"] = neuronParams.params[0];
+	params["rv:tau"] = neuronParams.params[1];
+	params["rv:gain"] = neuronParams.params[2];
+	params["rv:period"] = neuronParams.params[3];
+	params["rv:phase_offset"] = neuronParams.params[4];
+	params["rv:amplitude"] = neuronParams.params[5];
+	params["rv:alpha"] = neuronParams.params[6];
+	params["rv:energy"] = neuronParams.params[7];
+	} else {
+	  	params["rv:bias"] =1;
+	params["rv:tau"] = 1;
+	params["rv:gain"] = 1;
+	params["rv:period"] = 1;
+	params["rv:phase_offset"] = 1;
+	params["rv:amplitude"] = 1;
+	params["rv:alpha"] = 1;
+	params["rv:energy"] = 1;
+	}
+	revolve::brain::NeuronPtr newNeuron; 
+// 	std::cout << neuronType + " " + neuronId  + " was added in"+ " "+ neuronLayer << std::endl;
+	switch(node.type) {
+	    case NT_SENSOR: {
+	    	newNeuron.reset(new revolve::brain::InputNeuron(neuronId, params));
+
+		config.inputNeurons_.push_back(newNeuron);
+		config.inputPositionMap_[newNeuron] = i;
+		config.numInputNeurons_++;
+		break;
+	    }
+	    case NT_HIDDEN: {
+		switch(node.neuron_type) {
+		     case SIGMOID: {
+			newNeuron.reset(new revolve::brain::SigmoidNeuron(neuronId, params));
+			break;
+		     }
+		     case SIMPLE: {
+			newNeuron.reset(new revolve::brain::LinearNeuron(neuronId, params));
+			break;
+		     }
+		     case BIAS:{
+			newNeuron.reset(new revolve::brain::BiasNeuron(neuronId, params));
+			break;
+		     }
+		     case DIFFERENTIAL_CPG: {
+		     	newNeuron.reset(new revolve::brain::DifferentialCPG(neuronId, params));
+			break;
+		     }
+		     default: {
+		       	    std::cout << "i get here 7.311" << std::endl;
+			throw std::runtime_error("Robot brain error"); 
+		     }
+		}
+		config.hiddenNeurons_.push_back(newNeuron);
+		config.numHiddenNeurons_++;
+		break;
+	    }
+	    case NT_OUTPUT: {
+// 		std::cout << (node.neuron_type == INPUT?"input":"wtf") << std::endl;
+		switch(node.neuron_type) {
+		     case SIGMOID: {
+			newNeuron.reset(new revolve::brain::SigmoidNeuron(neuronId, params));
+			break;
+		     }
+		     case SIMPLE: {
+			newNeuron.reset(new revolve::brain::LinearNeuron(neuronId, params));
+			break;
+		     }
+		     case BIAS:{
+			newNeuron.reset(new revolve::brain::BiasNeuron(neuronId, params));
+			break;
+		     }
+		     case DIFFERENTIAL_CPG: {
+		     	newNeuron.reset(new revolve::brain::DifferentialCPG(neuronId, params));
+			break;
+		     }
+		     default: {
+		       std::cout << node.neuron_type << " " << BIAS << " " << INPUT << " " << SIGMOID << " " << SIMPLE << " " << DIFFERENTIAL_CPG << std:: endl;
+		       	    std::cout << "i get here 7.312" << std::endl;
+			throw std::runtime_error("Robot brain error"); 
+		     }
+		}
+		    config.outputNeurons_.push_back(newNeuron);
+		    config.outputPositionMap_[newNeuron] = i;
+		    config.numOutputNeurons_++;
+		break;
+	    }
+	    default: {
+		  std::cout << "i get here 7.313" << std::endl;
+		throw std::runtime_error("programmer is idiot error"); 
+	    }
+	}
+	config.allNeurons_.push_back(newNeuron);
+	config.idToNeuron_[neuronId] = newNeuron;
+    }
+    std::cout << config.numInputNeurons_ << std::endl;
+    std::cout << config.numOutputNeurons_ << std::endl;
+    
+    config.inputs_ = new double[config.numInputNeurons_];
+    config.outputs_ = new double[config.numOutputNeurons_];
+	    std::cout << "i get here 7.32 " << config.inputs_ << " " << config.inputs_[0] << std::endl;
+    size_t nlinks = 0;
+    for(InnovLinkGene &link: links) {
+        if(link.enable) {
+	    nlinks++;
+	    revolve::brain::NeuronPtr dst = config.allNeurons_[get_node_index(link.out_node_id())];
+	    revolve::brain::NeuralConnectionPtr newConnection(new revolve::brain::NeuralConnection(
+		config.allNeurons_[get_node_index(link.in_node_id())],
+		dst,
+		link.weight()));
+	    // Add reference to this connection to the destination neuron
+	    dst->AddIncomingConnection(dst->GetSocketId(), newConnection);
+	    config.connections_.push_back(newConnection);
+        }
+    }
+	    std::cout << "i get here 7.33" << std::endl;
+    assert(nlinks <= LINKS_MAX);
+    
+}
 void InnovGenome::init_phenotype(Network &net) {
     size_t nnodes = nodes.size();
     assert(nnodes <= NODES_MAX);
@@ -1297,31 +901,20 @@ node_size_t InnovGenome::get_node_index(int id) {
     return i;
 }
 
-void InnovGenome::delete_if_orphaned_hidden_node(int node_id) {
-    InnovNodeGene *node = get_node(node_id);
-    if( (node == nullptr) || (node->type != NT_HIDDEN) )
-        return;
+void InnovGenome::print(std::ostream &out) {
+    out<<"genomestart "<<genome_id<<std::endl;
 
-    bool found_link;
-    for(InnovLinkGene &link: links) {
-        if(link.in_node_id() == node_id || link.out_node_id() == node_id) {
-            found_link = true;
-            break;
-        }
-    }
+    //Output the traits
+    for(auto &t: traits)
+        t.print_to_file(out);
 
-    if(!found_link) {
-        auto iterator = nodes.begin() + (node - nodes.data());
-        assert(iterator->node_id == node_id);
-        nodes.erase(iterator);
-    }
-}
+    //Output the nodes
+    for(auto &n: nodes)
+        n.print_to_file(out);
 
-void InnovGenome::delete_link(InnovLinkGene *link) {
-    auto iterator = find_if(links.begin(), links.end(),
-                            [link](const InnovLinkGene &l) {
-                                return l.innovation_num == link->innovation_num;
-                            });
-    assert(iterator != links.end());
-    links.erase(iterator);
-}
+    //Output the genes
+    for(auto &g: links)
+        g.print_to_file(out);
+
+    out << "genomeend " << genome_id << std::endl;
+}
\ No newline at end of file
diff --git a/cpp/neat/accneat/src/innovgenome/innovgenome.h b/cpp/neat/accneat/src/innovgenome/innovgenome.h
index 118d5ec..1e0e37a 100644
--- a/cpp/neat/accneat/src/innovgenome/innovgenome.h
+++ b/cpp/neat/accneat/src/innovgenome/innovgenome.h
@@ -20,12 +20,13 @@
 #include "innovnodegene.h"
 #include "innovnodelookup.h"
 #include "innovation.h"
+#include "brain/split_cpg/extended_neural_network_controller.h"
 
 namespace NEAT {
 
     class InnovGenome : public Genome {
     public:
-        std::vector<Trait> traits;
+	std::vector<Trait> traits;
         std::vector<InnovNodeGene> nodes;
         std::vector<InnovLinkGene> links;
 
@@ -44,12 +45,11 @@ namespace NEAT {
         //Destructor kills off all lists (including the trait vector)
         virtual ~InnovGenome();
 
-        // Dump this genome to specified file
-        virtual void print(std::ostream &out) override;
-
         void duplicate_into(InnovGenome *offspring) const;
         InnovGenome &operator=(const InnovGenome &other);
 
+	// Dump this genome to specified file
+        virtual void print(std::ostream &out) override;
         // For debugging: A number of tests can be run on a genome to check its
         // integrity
         // Note: Some of these tests do not indicate a bug, but rather are meant
@@ -59,40 +59,11 @@ namespace NEAT {
 
         // ******* MUTATORS *******
 
-        // Perturb params in one trait
-        void mutate_random_trait();
-
-        // Change random link's trait. Repeat times times
-        void mutate_link_trait(int times);
-
-        // Change random node's trait times times
-        void mutate_node_trait(int times);
+	void mutate_random_trait();
 
         // Add Gaussian noise to linkweights either GAUSSIAN or COLDGAUSSIAN (from zero)
         void mutate_link_weights(real_t power,real_t rate,mutator mut_type);
 
-        // toggle links on or off
-        void mutate_toggle_enable(int times);
-
-        // Find first disabled gene and enable it
-        void mutate_gene_reenable();
-
-        // These last kinds of mutations return false if they fail
-        //   They can fail under certain conditions,  being unable
-        //   to find a suitable place to make the mutation.
-        //   Generally, if they fail, they can be called again if desired.
-
-        // Mutate genome by adding a node respresentation
-        bool mutate_add_node(CreateInnovationFunc create_innov,
-                             bool delete_split_link);
-
-        void mutate_delete_node();
-
-        void mutate_delete_link();
-
-        // Mutate the genome by adding a new link between 2 random InnovNodeGenes
-        bool mutate_add_link(CreateInnovationFunc create_innov,
-                             int tries);
 
         // ****** MATING METHODS *****
         static void mate(InnovGenome *genome1,
@@ -100,27 +71,11 @@ namespace NEAT {
                          InnovGenome *offspring,
                          real_t fitness1,
                          real_t fitness2);
-
-        //   For every point in each InnovGenome, where each InnovGenome shares
-        //   the innovation number, the InnovLinkGene is chosen randomly from
-        //   either parent.  If one parent has an innovation absent in
-        //   the other, the baby will inherit the innovation
-        //   Interspecies mating leads to all genes being inherited.
-        //   Otherwise, excess genes come from most fit parent.
-        static void mate_multipoint(InnovGenome *genome1,
-                                    InnovGenome *genome2,
-                                    InnovGenome *offspring,
-                                    real_t fitness1,
-                                    real_t fitness2);
-
-        //This method mates like multipoint but instead of selecting one
-        //   or the other when the innovation numbers match, it averages their
-        //   weights
-        static void mate_multipoint_avg(InnovGenome *genome1,
-                                        InnovGenome *genome2,
-                                        InnovGenome *offspring,
-                                        real_t fitness1,
-                                        real_t fitness2);
+	static void mate_multipoint(InnovGenome *genome1,
+                                  InnovGenome *genome2,
+                                  InnovGenome *offspring,
+                                  real_t fitness1,
+                                  real_t fitness2);
 
         // ******** COMPATIBILITY CHECKING METHODS ********
 
@@ -146,6 +101,7 @@ namespace NEAT {
         node_size_t get_node_index(int id);
 
         virtual void init_phenotype(class Network &net) override;
+	void init_phenotype(revolve::brain::ExtNNController::ExtNNConfig &config);
 
     public:
         void reset();
@@ -163,9 +119,7 @@ namespace NEAT {
 
     private:
         InnovLinkGene *find_link(int in_node_id, int out_node_id, bool is_recurrent);
-        void delete_if_orphaned_hidden_node(int node_id);
-        void delete_link(InnovLinkGene *link);
-
+	
         InnovNodeLookup node_lookup;
     };
 }
diff --git a/cpp/neat/accneat/src/innovgenome/innovgenomemanager.cpp b/cpp/neat/accneat/src/innovgenome/innovgenomemanager.cpp
index a7b5f2e..3a877c5 100644
--- a/cpp/neat/accneat/src/innovgenome/innovgenomemanager.cpp
+++ b/cpp/neat/accneat/src/innovgenome/innovgenomemanager.cpp
@@ -129,64 +129,24 @@ void InnovGenomeManager::mutate(Genome &genome_,
     case MUTATE_OP_STRUCTURE: {
         if(!allow_add && !allow_del) {
             mutate(genome_, MUTATE_OP_WEIGHTS);
-        } else {
-            if(!allow_del || genome_.rng.boolean()) {
-                genome->mutate_add_link(create_innov_func(genome_),
-                                        env->newlink_tries);
-            } else {
-                genome->mutate_delete_link();
-            }
-        }
+        } 
     } break;
     case MUTATE_OP_ANY: {
         rng_t &rng = genome->rng;
         rng_t::prob_switch_t op = rng.prob_switch();
-
-        if( allow_add && op.prob_case(env->mutate_add_node_prob) ) {
-            bool delete_split_link = env->search_type != GeneticSearchType::COMPLEXIFY;
-            genome->mutate_add_node(create_innov_func(genome_), delete_split_link);
-        } else if( allow_add && op.prob_case(env->mutate_add_link_prob) ) {
-            genome->mutate_add_link(create_innov_func(genome_),
-                                    env->newlink_tries);
-        } else if( allow_del && op.prob_case(env->mutate_delete_link_prob) ) {
-            genome->mutate_delete_link();
-        } else if( allow_del && op.prob_case(env->mutate_delete_node_prob) ) {
-            genome->mutate_delete_node();
-        } else {
-            //Only do other mutations when not doing sturctural mutations
-            if( rng.under(env->mutate_random_trait_prob) ) {
-                genome->mutate_random_trait();
-            }
-            if( rng.under(env->mutate_link_trait_prob) ) {
-                genome->mutate_link_trait(1);
-            }
-            if( rng.under(env->mutate_node_trait_prob) ) {
-                genome->mutate_node_trait(1);
-            }
-            if( rng.under(env->mutate_link_weights_prob) ) {
-                genome->mutate_link_weights(env->weight_mut_power,
-                                            1.0,
-                                            GAUSSIAN);
-            }
-
-            if(env->search_type == GeneticSearchType::COMPLEXIFY) {
-                if( rng.under(env->mutate_toggle_enable_prob) ) {
-                    genome->mutate_toggle_enable(1);
-                }
-                if (rng.under(env->mutate_gene_reenable_prob) ) {
-                    genome->mutate_gene_reenable();
-                }
-            }
-        }
+	//Only do other mutations when not doing sturctural mutations
+	if( rng.under(env->mutate_random_trait_prob) ) {
+	    genome->mutate_random_trait();
+	}
+	if( rng.under(env->mutate_link_weights_prob) ) {
+	    genome->mutate_link_weights(env->weight_mut_power,
+					1.0,
+					GAUSSIAN);
+	}
     } break;
     default:
         panic();
     }
-
-    if(genome->links.size() == 0) {
-        genome->mutate_add_link(create_innov_func(genome_),
-                                env->newlink_tries);
-    }
 }
 
 void InnovGenomeManager::finalize_generation(bool new_fittest) {
diff --git a/cpp/neat/accneat/src/innovgenome/innovnodegene.cpp b/cpp/neat/accneat/src/innovgenome/innovnodegene.cpp
index b71f5a1..946b766 100644
--- a/cpp/neat/accneat/src/innovgenome/innovnodegene.cpp
+++ b/cpp/neat/accneat/src/innovgenome/innovnodegene.cpp
@@ -17,8 +17,9 @@
 #include <sstream>
 using namespace NEAT;
 
-InnovNodeGene::InnovNodeGene(nodetype ntype,int nodeid) {
+InnovNodeGene::InnovNodeGene(nodetype ntype,int nodeid, neurontype neuron_type) {
     type=ntype; //NEURON or SENSOR type
+    this->neuron_type = neuron_type;
     node_id=nodeid;
     frozen=false;
     trait_id=1;
@@ -41,6 +42,14 @@ InnovNodeGene::InnovNodeGene (const char *argline) {
 InnovNodeGene::~InnovNodeGene() {
 }
 
+InnovNodeGene & InnovNodeGene::operator=(const InnovNodeGene &other) {
+    this->type = other.get_type();
+    this->neuron_type = other.neuron_type;
+    this->node_id = other.node_id;
+    this->frozen = other.frozen;
+    this->trait_id = other.get_trait_id();
+}
+
 void InnovNodeGene::print_to_file(std::ostream &outFile) {
     outFile<<"node "<<node_id<<" ";
     outFile<<trait_id<<" ";
diff --git a/cpp/neat/accneat/src/innovgenome/innovnodegene.h b/cpp/neat/accneat/src/innovgenome/innovnodegene.h
index 7545c71..ebbc6a9 100644
--- a/cpp/neat/accneat/src/innovgenome/innovnodegene.h
+++ b/cpp/neat/accneat/src/innovgenome/innovnodegene.h
@@ -26,15 +26,20 @@ namespace NEAT {
     public:
         bool frozen; // When frozen, cannot be mutated (meaning its trait pointer is fixed)
         nodetype type;
+	neurontype neuron_type;
+	
         int node_id;  // A node can be given an identification number for saving in files
 
         // Construct InnovNodeGene with invalid state.
         InnovNodeGene() {}
-        InnovNodeGene(nodetype ntype,int nodeid);
+        InnovNodeGene(nodetype ntype,int nodeid, neurontype neuron_type);
         // Construct the node out of a file specification using given list of traits
         InnovNodeGene (const char *argline);
 
         ~InnovNodeGene();
+	
+	InnovNodeGene &operator=(const InnovNodeGene &other);
+
 
         inline void set_trait_id(int id) { assert(id > 0); trait_id = id; }
         inline int get_trait_id() const {return trait_id;}
diff --git a/cpp/neat/accneat/src/innovgenome/trait.cpp b/cpp/neat/accneat/src/innovgenome/trait.cpp
index 8684bfe..5a56319 100644
--- a/cpp/neat/accneat/src/innovgenome/trait.cpp
+++ b/cpp/neat/accneat/src/innovgenome/trait.cpp
@@ -93,11 +93,12 @@ void Trait::print_to_file(std::ostream &outFile) {
 }
 
 void Trait::mutate(rng_t &rng) {
-    for(int count=0;count<NUM_TRAIT_PARAMS;count++) {
-        if (rng.prob()>env->trait_param_mut_prob) {
-            params[count]+=(rng.posneg()*rng.prob())*env->trait_mutation_power;
-            if (params[count]<0) params[count]=0;
-            if (params[count]>1.0) params[count]=1.0;
-        }
-    }
+//     for(int count=0;count<NUM_TRAIT_PARAMS;count++) {
+// 	
+//         if (rng.prob()>env->trait_param_mut_prob) { //TODO:: shouldnt it be <?
+//             params[count]+=(rng.posneg()*rng.prob())*env->trait_mutation_power;
+//             if (params[count]<0) params[count]=0;
+//             if (params[count]>1.0) params[count]=1.0;
+//         }
+//     }
 }
diff --git a/cpp/neat/accneat/src/main.cpp b/cpp/neat/accneat/src/main.cpp
index ed1cd4f..744d92f 100644
--- a/cpp/neat/accneat/src/main.cpp
+++ b/cpp/neat/accneat/src/main.cpp
@@ -15,7 +15,7 @@
 */
 //#include "std.h" // Must be included first. Precompiled header with standard library includes.
 #include <unistd.h>
-#include "experiments/experiment.h"
+// #include "experiments/experiment.h"
 #include "neat.h"
 #include "util/rng.h"
 #include "util/util.h"
@@ -30,28 +30,28 @@ using namespace NEAT;
 #define DEFAULT_MAX_GENS 10000
 
 void usage() {
-    std::cerr << "usage: neat [OPTIONS]... experiment_name" << std::endl;
-    std::cerr << std::endl;
-    std::cerr << "experiment names: ";
-    auto names = Experiment::get_names();
-    for(size_t i = 0; i < names.size(); i++) {
-        if(i != 0)
-            std::cerr << ", ";
-        std::cerr << names[i];
-    }
-    std::cerr << std::endl;
-    std::cerr << std::endl;
-
-    std::cerr << "OPTIONS" << std::endl;
-    std::cerr << "  -f                   Force deletion of any data from previous run." << std::endl;
-    std::cerr << "  -c num_experiments   (default=" << env->num_runs << ")" << std::endl;
-    std::cerr << "  -r RNG_seed          (default=" << DEFAULT_RNG_SEED << ")" << std::endl;
-    std::cerr << "  -n population_size   (default=" << env->pop_size << ")" << std::endl;
-    std::cerr << "  -x max_generations   (default=" << DEFAULT_MAX_GENS << ")" << std::endl;
-    std::cerr << "  -s search_type       {phased, blended, complexify} (default=phased)" << std::endl;
-
-
-    exit(1);
+//     std::cerr << "usage: neat [OPTIONS]... experiment_name" << std::endl;
+//     std::cerr << std::endl;
+//     std::cerr << "experiment names: ";
+//     auto names = Experiment::get_names();
+//     for(size_t i = 0; i < names.size(); i++) {
+//         if(i != 0)
+//             std::cerr << ", ";
+//         std::cerr << names[i];
+//     }
+//     std::cerr << std::endl;
+//     std::cerr << std::endl;
+// 
+//     std::cerr << "OPTIONS" << std::endl;
+//     std::cerr << "  -f                   Force deletion of any data from previous run." << std::endl;
+//     std::cerr << "  -c num_experiments   (default=" << env->num_runs << ")" << std::endl;
+//     std::cerr << "  -r RNG_seed          (default=" << DEFAULT_RNG_SEED << ")" << std::endl;
+//     std::cerr << "  -n population_size   (default=" << env->pop_size << ")" << std::endl;
+//     std::cerr << "  -x max_generations   (default=" << DEFAULT_MAX_GENS << ")" << std::endl;
+//     std::cerr << "  -s search_type       {phased, blended, complexify} (default=phased)" << std::endl;
+// 
+// 
+//     exit(1);
 }
 
 template<typename T>
@@ -127,15 +127,15 @@ int main(int argc, char *argv[]) {
         env->mutate_delete_link_prob *= 0.1;
     }
 
-    const char *experiment_name = argv[optind++];
-
-    Experiment *exp = Experiment::get(experiment_name);
-    if(exp == nullptr) {
-        trap("No such experiment: " << experiment_name);
-    }
-
-    rng_t rng{rng_seed};
-    exp->run(rng, maxgens);
+//     const char *experiment_name = argv[optind++];
+// 
+//     Experiment *exp = Experiment::get(experiment_name);
+//     if(exp == nullptr) {
+//         trap("No such experiment: " << experiment_name);
+//     }
+// 
+//     rng_t rng{rng_seed};
+//     exp->run(rng, maxgens);
 
     return(0);
 }
diff --git a/cpp/neat/accneat/src/multinnspecies/multinnspeciesorganism.cpp b/cpp/neat/accneat/src/multinnspecies/multinnspeciesorganism.cpp
index b81e5cf..26ca581 100644
--- a/cpp/neat/accneat/src/multinnspecies/multinnspeciesorganism.cpp
+++ b/cpp/neat/accneat/src/multinnspecies/multinnspeciesorganism.cpp
@@ -7,14 +7,14 @@ using namespace std;
 
 MultiNNSpeciesOrganism::MultiNNSpeciesOrganism(const MultiNNSpeciesOrganism &other) {
     this->genome = env->genome_manager->make_default();
-    this->net = unique_ptr<Network>(Network::create());
+    this->net = unique_ptr<revolve::brain::ExtNNController>(new revolve::brain::ExtNNController());
     other.copy_into(*this);
 }
 
 MultiNNSpeciesOrganism::MultiNNSpeciesOrganism(const Genome &genome) {
     this->genome = env->genome_manager->make_default();
     *this->genome = genome;
-    this->net = unique_ptr<Network>(Network::create());
+    this->net = unique_ptr<revolve::brain::ExtNNController>(new revolve::brain::ExtNNController());
     init(0);
 }
 
diff --git a/cpp/neat/accneat/src/neattypes.h b/cpp/neat/accneat/src/neattypes.h
index 116e89c..004d79d 100644
--- a/cpp/neat/accneat/src/neattypes.h
+++ b/cpp/neat/accneat/src/neattypes.h
@@ -21,6 +21,13 @@ namespace NEAT {
         NT_OUTPUT = 2,
         NT_HIDDEN = 3
     };
+    enum neurontype {
+	SIMPLE = 0,
+	SIGMOID = 1,
+	DIFFERENTIAL_CPG = 2,
+	INPUT =3,
+	BIAS = 4
+    };
 
     struct OrganismEvaluation {
         real_t fitness;
diff --git a/cpp/neat/accneat/src/network/network.h b/cpp/neat/accneat/src/network/network.h
index 0d3c149..e959663 100644
--- a/cpp/neat/accneat/src/network/network.h
+++ b/cpp/neat/accneat/src/network/network.h
@@ -53,6 +53,7 @@ namespace NEAT {
     struct NetNode {
         link_size_t incoming_start;
         link_size_t incoming_end;
+	nodetype type;
     };
 
     //---
diff --git a/cpp/neat/accneat/src/organism.cpp b/cpp/neat/accneat/src/organism.cpp
index fc9184c..15e09b9 100644
--- a/cpp/neat/accneat/src/organism.cpp
+++ b/cpp/neat/accneat/src/organism.cpp
@@ -25,14 +25,14 @@ using namespace NEAT;
 
 Organism::Organism(const Organism &other) {
     this->genome = env->genome_manager->make_default();
-    this->net = std::unique_ptr<Network>(Network::create());
+    this->net = std::unique_ptr<revolve::brain::ExtNNController>(new revolve::brain::ExtNNController());
     other.copy_into(*this);
 }
 
 Organism::Organism(const Genome &genome) {
     this->genome = env->genome_manager->make_default();
     *this->genome = genome;
-    this->net = std::unique_ptr<Network>(Network::create());
+    this->net = std::unique_ptr<revolve::brain::ExtNNController>(new revolve::brain::ExtNNController());
 
     //Note: We're in the base class constructor, so a derived class' init() won't
     //      be called. The derived class' constructor must also call init().
@@ -68,8 +68,8 @@ void Organism::copy_into(Organism &dst) const {
     copy(generation);
 
     // Networks must be regenerated.
-    dst.net = std::unique_ptr<Network>(Network::create());
-
+    revolve::brain::ExtNNController * ext = new revolve::brain::ExtNNController();
+    dst.net.reset(ext);
 
 #undef copy
 }
diff --git a/cpp/neat/accneat/src/organism.h b/cpp/neat/accneat/src/organism.h
index 5d252ec..34bd520 100644
--- a/cpp/neat/accneat/src/organism.h
+++ b/cpp/neat/accneat/src/organism.h
@@ -16,7 +16,7 @@
 #pragma once
 
 #include "genome.h"
-#include "network/network.h"
+#include "brain/split_cpg/extended_neural_network_controller.h"
 
 #include <memory>
 
@@ -36,7 +36,7 @@ namespace NEAT {
 
         OrganismEvaluation eval;
         std::unique_ptr<Genome> genome; //The Organism's genotype
-        std::unique_ptr<Network> net;  //The Organism's phenotype
+        std::unique_ptr<revolve::brain::ExtNNController> net;  //The Organism's phenotype
         int generation;  //Tells which generation this Organism is from
 
         Organism(const Organism &other);
diff --git a/cpp/neat/accneat/src/species/speciesorganism.cpp b/cpp/neat/accneat/src/species/speciesorganism.cpp
index 058e10f..9409305 100644
--- a/cpp/neat/accneat/src/species/speciesorganism.cpp
+++ b/cpp/neat/accneat/src/species/speciesorganism.cpp
@@ -7,14 +7,14 @@ using namespace std;
 
 SpeciesOrganism::SpeciesOrganism(const SpeciesOrganism &other) {
     this->genome = env->genome_manager->make_default();
-    this->net = unique_ptr<Network>(Network::create());
+    this->net.reset(new revolve::brain::ExtNNController());
     other.copy_into(*this);
 }
 
 SpeciesOrganism::SpeciesOrganism(const Genome &genome) {
     this->genome = env->genome_manager->make_default();
     *this->genome = genome;
-    this->net = unique_ptr<Network>(Network::create());
+    this->net.reset(new revolve::brain::ExtNNController());
     init(0);
 }
 
diff --git a/cpp/neat/accneat/src/species/speciespopulation.cpp b/cpp/neat/accneat/src/species/speciespopulation.cpp
index 7d05def..f89a698 100644
--- a/cpp/neat/accneat/src/species/speciespopulation.cpp
+++ b/cpp/neat/accneat/src/species/speciespopulation.cpp
@@ -71,13 +71,14 @@ void SpeciesPopulation::verify() {
 
 void SpeciesPopulation::spawn() {
     orgs.init_phenotypes();
-
+         std::cout << "i get here 7.5" << std::endl;
     //Separate the new SpeciesPopulation into species
     speciate();
 }
 
 void SpeciesPopulation::speciate() {
     last_species = 0;
+             std::cout << "i get here 8" << std::endl;
     for(SpeciesOrganism &org: orgs.curr()) {
         assert(org.species == nullptr);
         for(Species *s: species) {
@@ -87,6 +88,7 @@ void SpeciesPopulation::speciate() {
                 break;
             }
         }
+                 std::cout << "i get here 9" << std::endl;
         if(!org.species) {
             Species *s = new Species(++last_species);
             species.push_back(s);
diff --git a/cpp/neat/accneat/src/util/organismsbuffer.h b/cpp/neat/accneat/src/util/organismsbuffer.h
index 1c4b6c9..228e8be 100644
--- a/cpp/neat/accneat/src/util/organismsbuffer.h
+++ b/cpp/neat/accneat/src/util/organismsbuffer.h
@@ -1,8 +1,10 @@
 #pragma once
 
 #include "organism.h"
+#include "innovgenome/innovgenome.h"
 #include "rng.h"
 #include <assert.h>
+#include <iostream>
 
 namespace NEAT {
 
@@ -23,7 +25,7 @@ namespace NEAT {
             _b.reserve(n);
             _curr = &_a;
             _prev = &_b;
-
+         std::cout << "i get here 6" << std::endl;
             for(size_t i = 0; i < n; i++) {
                 _a.emplace_back(*seeds[i + population_index]);
                 size_t ipop = i + population_index;
@@ -40,13 +42,17 @@ namespace NEAT {
                 _b[i].genome->genome_id = ipop;
                 _b[i].genome->rng.seed(rng.integer());
             }
+            std::cout << "i get here 7" << std::endl;
         }
 
         void init_phenotypes() {
 #pragma omp parallel for
             for(size_t i = 0; i < _n; i++) {
                 Organism &org = curr()[i];
-                org.genome->init_phenotype(*org.net);
+		         std::cout << "i get here 7.2" << std::endl;
+		revolve::brain::ExtNNController::ExtNNConfig config;
+                dynamic_cast<InnovGenome *>(org.genome.get())->init_phenotype(config);
+		org.net->configure("TEST", config); 
             }
         }
 
diff --git a/cpp/neat/asyncneat.cpp b/cpp/neat/asyncneat.cpp
index 0fe6356..69a2191 100644
--- a/cpp/neat/asyncneat.cpp
+++ b/cpp/neat/asyncneat.cpp
@@ -23,7 +23,7 @@ AsyncNeat::AsyncNeat(unsigned int n_inputs, unsigned int n_outputs, int rng_seed
         " [remember also to call AsyncNeat::CleanUp() after finised using all"
         " AsyncNEAT objects]");
     }
-
+    std::cout << "i get here 3" << std::endl;
     NEAT::rng_t rng{rng_seed};
     NEAT::rng_t rng_exp(rng.integer());
     std::vector<std::unique_ptr<NEAT::Genome>> genomes =
@@ -33,8 +33,11 @@ AsyncNeat::AsyncNeat(unsigned int n_inputs, unsigned int n_outputs, int rng_seed
                                                             n_inputs,
                                                             n_outputs,
                                                             n_inputs);
+    std::cout << "i get here 4" << std::endl;
     //Spawn the Population
+    std::cout << genomes.size() << std::endl;
     population = NEAT::Population::create(rng_exp, genomes);
+        std::cout << "i get here 5" << std::endl;
     refill_evaluation_queue();
 }
 
diff --git a/neat.diff b/neat.diff
new file mode 100644
index 0000000..561f431
--- /dev/null
+++ b/neat.diff
@@ -0,0 +1,3334 @@
+diff --git a/cpp/CMakeLists.txt b/cpp/CMakeLists.txt
+index 2557f7c..6400d92 100644
+--- a/cpp/CMakeLists.txt
++++ b/cpp/CMakeLists.txt
+@@ -52,7 +52,8 @@ file(GLOB_RECURSE BRAIN_SRCS
+         brain/supg/supgneuron.cpp
+         brain/supg/supggenomemanager.cpp
+         neat/asyncneat.cpp
+-        neat/neatevaluation.cpp)
++        neat/neatevaluation.cpp
++        brain/basic_neat_brain.cpp)
+ 
+ # Compiling ####################################################################
+ add_library(revolve-brain-static STATIC ${BRAIN_SRCS})
+diff --git a/cpp/brain/basic_neat_brain.cpp b/cpp/brain/basic_neat_brain.cpp
+new file mode 100644
+index 0000000..069c608
+--- /dev/null
++++ b/cpp/brain/basic_neat_brain.cpp
+@@ -0,0 +1,87 @@
++#include "basic_neat_brain.h"
++#include "neat/asyncneat.h"
++#include <sstream>
++#include <stdexcept>
++#include <limits>
++#include <iomanip>
++#include <string>
++#include <ctime>
++
++using namespace revolve::brain;
++
++
++BasicBrain::BasicBrain(EvaluatorPtr evaluator,
++                     const std::vector< ActuatorPtr >& actuators,
++                     const std::vector< SensorPtr >& sensors)
++  : evaluator(evaluator)
++  , start_eval_time(std::numeric_limits< double >::lowest())
++  , generation_counter(0)
++
++{
++    unsigned int p = 0;
++    std::cout<<"sensor->sensorId()"<<std::endl;
++    for (auto sensor : sensors) {
++        std::cout << "sensor: " << sensor->sensorId() << "(inputs: " << sensor->inputs() << ")" << std::endl;
++        p += sensor->inputs();
++    }
++    std::cout<<"END sensor->sensorId()"<<std::endl;
++    n_inputs = p;
++
++    p = 0;
++    for (auto actuator : actuators) {
++        p += actuator->outputs();
++    }
++    n_outputs = p;
++
++    this->init_async_neat();
++}
++
++void BasicBrain::init_async_neat() {
++    AsyncNeat::Init();
++    unsigned long populationSize = 10;
++    NEAT::GeneticSearchType geneticSearchType = NEAT::GeneticSearchType::PHASED;
++
++
++    AsyncNeat::SetPopulationSize(populationSize); // 10 - 25 - 50 - 75 - 100 - 1000
++    AsyncNeat::SetSearchType(geneticSearchType);
++    std::unique_ptr< AsyncNeat > neat(new AsyncNeat(
++        n_inputs,
++        n_outputs,
++        std::time(0)
++    ));
++    this->neat = std::move(neat);
++}
++
++
++void BasicBrain::update(const std::vector< ActuatorPtr >& actuators,
++                       const std::vector< SensorPtr >& sensors,
++                       double t, double step)
++{
++    this->update<std::vector<ActuatorPtr>, std::vector<SensorPtr>>(actuators, sensors, t, step);
++}
++
++double BasicBrain::getFitness()
++{
++    //Calculate fitness for current policy
++    double fitness = evaluator->fitness();
++    std::cout << "Evaluating gait, fitness = " << fitness << std::endl;
++    return fitness;
++}
++
++void BasicBrain::nextBrain()
++{
++    bool init_supgs;
++    if (!current_evalaution) {
++        // first evaluation
++        init_supgs = true;
++    } else {
++        // normal change of evaluation
++        init_supgs = false;
++        current_evalaution->finish(getFitness());
++    }
++
++    current_evalaution = neat->getEvaluation();
++    cppn = reinterpret_cast< NEAT::CpuNetwork* > (
++        current_evalaution->getOrganism()->net.get()
++    );
++}
+diff --git a/cpp/brain/basic_neat_brain.h b/cpp/brain/basic_neat_brain.h
+new file mode 100644
+index 0000000..58827cc
+--- /dev/null
++++ b/cpp/brain/basic_neat_brain.h
+@@ -0,0 +1,139 @@
++#ifndef REVOLVE_BRAIN_BASIC_NEAT_BRAIN_H
++#define REVOLVE_BRAIN_BASIC_NEAT_BRAIN_H
++
++#include "brain.h"
++#include "neat/asyncneat.h"
++#include "evaluator.h"
++#include "neat/accneat/src/network/cpu/cpunetwork.h"
++
++#include <vector>
++#include <memory>
++#include <iostream>
++
++namespace revolve {
++namespace brain {
++
++class BasicBrain : public Brain
++{
++//METHODS
++public:
++    BasicBrain(EvaluatorPtr evaluator,
++              const std::vector< ActuatorPtr >& actuators,
++              const std::vector< SensorPtr >& sensors);
++    ~BasicBrain() {}
++
++    virtual void update(const std::vector< ActuatorPtr >& actuators,
++                        const std::vector< SensorPtr >& sensors,
++                        double t, double step) override;
++
++protected:
++
++    template<typename ActuatorContainer, typename SensorContainer>
++    void update(const ActuatorContainer &actuators,
++                const SensorContainer &sensors,
++                double t,
++                double step)
++    {
++
++        // Evaluate policy on certain time limit
++        if ((t-start_eval_time) > BasicBrain::FREQUENCY_RATE) {
++
++            // check if to stop the experiment. Negative value for MAX_EVALUATIONS will never stop the experiment
++            if (BasicBrain::MAX_EVALUATIONS > 0 && generation_counter > BasicBrain::MAX_EVALUATIONS) {
++                std::cout << "Max Evaluations (" << BasicBrain::MAX_EVALUATIONS << ") reached. stopping now." << std::endl;
++                std::exit(0);
++            }
++            generation_counter++;
++            std::cout << "################# EVALUATING NEW BRAIN !!!!!!!!!!!!!!!!!!!!!!!!! (generation " << generation_counter << " )" << std::endl;
++            this->nextBrain();
++            start_eval_time = t;
++            evaluator->start();
++        }
++
++        assert(n_outputs == actuators.size());
++
++        // Read sensor data and feed the neural network
++        std::vector<double> inputs(n_inputs,0);
++        unsigned int p = 0;
++        for (auto sensor : sensors) {
++            sensor->read(&inputs[p]);
++            p += sensor->inputs();
++        }
++        assert(p == n_inputs);
++	std::vector<float> floatIns(n_inputs,0);
++	for(unsigned int i = 0; i < n_inputs; i++) {
++	    floatIns[i] = inputs[i];
++// 	    std::cout << inputs[i] << " " << floatIns[i] << " ";
++	}	
++// 	std::cout << n_inputs << " " << n_outputs;
++	NEAT::NetDims dims = cppn->get_dims();
++	std::cout << dims.nlinks << " " << dims.nnodes.all;
++// 	std::cout << std::endl;
++	cppn->set_activations(floatIns);
++	
++
++        // Activate network and save results
++	cppn->activate(1);
++	std::vector<float> outputvect(n_outputs, 0);
++        cppn->get_activations(outputvect).data();
++	std::vector<double> outputDouble(n_outputs,0);
++	for(unsigned int i = 0; i < n_outputs; i++) {
++	    outputDouble[i] = outputvect[i];
++// 	    std::cout << outputDouble[i] << " " << outputvect[i] << " ";
++	}	
++// 	std::cout << std::endl;
++	double *outputs = outputDouble.data();
++        // send signals to actuators
++        p = 0;
++        for (auto actuator: actuators) {
++            actuator->update(&outputs[p], step);
++            p += actuator->outputs();
++        }
++        assert(p == n_outputs);
++    }
++
++    void init_async_neat();
++
++private:
++    double getFitness();
++    void nextBrain();
++// DATA
++protected:
++    unsigned int n_inputs, n_outputs;
++
++private:
++    std::unique_ptr<AsyncNeat> neat;
++    EvaluatorPtr evaluator;
++    double start_eval_time;
++    unsigned int generation_counter;
++    std::shared_ptr< NeatEvaluation > current_evalaution;
++    NEAT::CpuNetwork *cppn;
++
++    /**
++     * Number of evaluations before the program quits. Usefull to do long run
++     * tests. If negative (default value), it will never stop.
++     *
++     * Takes value from env variable SUPG_MAX_EVALUATIONS.
++     * Default value -1
++     */
++    const long MAX_EVALUATIONS= -1; // max number of evaluations
++    /**
++     * How long should an evaluation lasts (in seconds)
++     *
++     * Takes value from env variable SUPG_FREQUENCY_RATE
++     * Default value 30 seconds
++     */
++    const double FREQUENCY_RATE= 30; // seconds
++    /**
++     * How long should the supg timer cicle be (in seconds)
++     *
++     * Takes value from env variable SUPG_CYCLE_LENGTH
++     * Default value 5 seconds
++     */
++    const double CYCLE_LENGTH = 5; // seconds
++};
++
++}
++}
++
++#endif // REVOLVE_BRAIN_BASIC_NEAT_BRAIN_H
+diff --git a/cpp/brain/innovgenome/innovation.cpp b/cpp/brain/innovgenome/innovation.cpp
+new file mode 100644
+index 0000000..ed4e773
+--- /dev/null
++++ b/cpp/brain/innovgenome/innovation.cpp
+@@ -0,0 +1,198 @@
++    /*
++ Copyright 2001 The University of Texas at Austin
++
++   Licensed under the Apache License, Version 2.0 (the "License");
++   you may not use this file except in compliance with the License.
++   You may obtain a copy of the License at
++
++       http://www.apache.org/licenses/LICENSE-2.0
++
++   Unless required by applicable law or agreed to in writing, software
++   distributed under the License is distributed on an "AS IS" BASIS,
++   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++   See the License for the specific language governing permissions and
++   limitations under the License.
++*/
++
++#include "innovation.h"
++#include "util/util.h"
++
++#ifdef WITH_OPENMP
++#include <omp.h>
++#endif
++
++#include <algorithm>
++#include <vector>
++
++using namespace NEAT;
++
++static int cmp(const InnovationId &x, const InnovationId &y) {
++#define __cmp(val)                              \
++    if(x.val < y.val) {return -1;}              \
++    else if(x.val > y.val) {return 1;}
++
++    __cmp(innovation_type);
++    __cmp(node_in_id);
++    __cmp(node_out_id);
++
++    switch(x.innovation_type) {
++    case NEWNODE:
++        __cmp(old_innov_num);
++        return 0;
++    case NEWLINK:
++        __cmp(recur_flag);
++        return 0;
++    default:
++        trap("invalid innovation_type");
++    }
++
++#undef __cmp
++}
++
++InnovationId::InnovationId(int nin,
++                           int nout,
++                           int oldinnov)
++    : innovation_type(NEWNODE)
++    , node_in_id(nin)
++    , node_out_id(nout)
++    , old_innov_num(oldinnov)
++    , recur_flag(false) { // unused
++}
++
++InnovationId::InnovationId(int nin,
++                           int nout,
++                           bool recur)
++    : innovation_type(NEWLINK)
++    , node_in_id(nin)
++    , node_out_id(nout)
++    , old_innov_num(-1) // unused
++    , recur_flag(recur) {
++}
++
++bool InnovationId::operator<(const InnovationId &other) const {
++    return ::cmp(*this, other) < 0;
++}
++
++bool InnovationId::operator==(const InnovationId &other) const {
++    return ::cmp(*this, other) == 0;
++}
++
++InnovationParms::InnovationParms()
++    : new_weight(-1)
++    , new_trait_id(-1) {
++}
++
++InnovationParms::InnovationParms(real_t w,
++                                 int t)
++    : new_weight(w)
++    , new_trait_id(t) {
++}
++
++IndividualInnovation::IndividualInnovation(int population_index_,
++                                           InnovationId id_,
++                                           InnovationParms parms_,
++                                           ApplyFunc apply_)
++    : population_index(population_index_)
++    , id(id_)
++    , parms(parms_) {
++    apply = apply_;
++}
++
++// Link
++Innovation::Innovation(InnovationId id_,
++                       InnovationParms parms_,
++                       int innovation_num1_)
++    : id(id_)
++    , parms(parms_)
++    , innovation_num1(innovation_num1_) {
++}
++
++// Node
++Innovation::Innovation(InnovationId id_,
++                       InnovationParms parms_,
++                       int innovation_num1_,
++                       int innovation_num2_,
++                       int newnode_id_)
++    : id(id_)
++    , parms(parms_)
++    , innovation_num1(innovation_num1_)
++    , innovation_num2(innovation_num2_)
++    , newnode_id(newnode_id_) {
++}
++
++static bool cmp_ind(const IndividualInnovation &x, const IndividualInnovation &y) {
++    return x.population_index < y.population_index;
++};
++
++void PopulationInnovations::init(int node_id, int innov_num) {
++    cur_node_id = node_id;
++    cur_innov_num = innov_num;
++
++#ifdef WITH_OPENMP
++    innovations.resize( omp_get_max_threads() );
++#else
++    innovations.resize( 1 );
++#endif
++}
++
++void PopulationInnovations::add(const IndividualInnovation &innov) {
++#ifdef WITH_OPENMP
++    innovations[omp_get_thread_num()].push_back(innov);
++#else
++    innovations[0].push_back(innov);
++#endif
++}
++
++void PopulationInnovations::apply() {
++    id2inds.clear();
++    for(std::vector<IndividualInnovation> &inds: innovations) {
++        for(auto &ind: inds) {
++            id2inds[ind.id].push_back(ind);
++        }
++        inds.clear();
++    }
++
++    std::vector<IndividualInnovation> masters;
++    for(auto &kv: id2inds) {
++        auto &inds = kv.second;
++
++        std::sort(inds.begin(), inds.end(), cmp_ind);
++
++        auto &master = inds.front();
++        masters.push_back(master);
++    }
++
++    std::sort(masters.begin(), masters.end(), cmp_ind);
++
++    for(auto &master: masters) {
++        auto &inds = id2inds[master.id];
++
++        Innovation *innov;
++
++        switch(master.id.innovation_type) {
++        case NEWNODE: {
++            innov = new Innovation(master.id,
++                                   master.parms,
++                                   cur_innov_num,
++                                   cur_innov_num + 1,
++                                   cur_node_id);
++            cur_innov_num += 2;
++            cur_node_id += 1;
++        } break;
++        case NEWLINK: {
++            innov = new Innovation(master.id,
++                                   master.parms,
++                                   cur_innov_num);
++            cur_innov_num += 1;
++        } break;
++        default:
++            trap("here");
++        }
++
++        for(IndividualInnovation &ind: inds) {
++            ind.apply(innov);
++        }
++
++        delete innov;
++    }
++}
+diff --git a/cpp/brain/innovgenome/innovation.h b/cpp/brain/innovgenome/innovation.h
+new file mode 100644
+index 0000000..d59bf01
+--- /dev/null
++++ b/cpp/brain/innovgenome/innovation.h
+@@ -0,0 +1,110 @@
++/*
++  Copyright 2001 The University of Texas at Austin
++
++  Licensed under the Apache License, Version 2.0 (the "License");
++  you may not use this file except in compliance with the License.
++  You may obtain a copy of the License at
++
++  http://www.apache.org/licenses/LICENSE-2.0
++
++  Unless required by applicable law or agreed to in writing, software
++  distributed under the License is distributed on an "AS IS" BASIS,
++  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++  See the License for the specific language governing permissions and
++  limitations under the License.
++*/
++#ifndef _INNOVATION_H_
++#define _INNOVATION_H_
++
++#include "neat.h"
++#include <functional>
++#include <map>
++
++namespace NEAT {
++
++    enum innovtype {
++        NEWNODE = 0,
++        NEWLINK = 1
++    };
++
++    class InnovationId {
++    public:
++        innovtype innovation_type;
++        int node_in_id;
++        int node_out_id;
++        int old_innov_num;
++        bool recur_flag;
++
++        // Node
++        InnovationId(int nin, int nout, int oldinnov);
++        // Link
++        InnovationId(int nin, int nout, bool recur);
++
++        bool operator<(const InnovationId &other) const;
++        bool operator==(const InnovationId &other) const;
++    };
++
++    class InnovationParms {
++    public:
++        real_t new_weight;
++        int new_trait_id;
++
++        InnovationParms();
++        InnovationParms(real_t w, int t);
++    };
++
++    class IndividualInnovation {
++    public:
++        typedef std::function<void (const class Innovation *innov)> ApplyFunc;
++
++        int population_index;
++        InnovationId id;
++        InnovationParms parms;
++        ApplyFunc apply;
++
++        IndividualInnovation(int population_index_,
++                             InnovationId id_,
++                             InnovationParms parms_,
++                             ApplyFunc apply_);
++    };
++
++    typedef std::function<void (InnovationId id,
++                                InnovationParms parms,
++                                IndividualInnovation::ApplyFunc func )> CreateInnovationFunc;
++
++    class Innovation {
++    public:
++        InnovationId id;
++        InnovationParms parms;
++
++        int innovation_num1;  //The number assigned to the innovation
++        int innovation_num2;  // If this is a new node innovation, then there are 2 innovations (links) added for the new node
++        int newnode_id;  // If a new node was created, this is its node_id
++
++        // Link
++        Innovation(InnovationId id_,
++                   InnovationParms parms_,
++                   int innovation_num1_);
++
++        // Node
++        Innovation(InnovationId id_,
++                   InnovationParms parms_,
++                   int innovation_num1_,
++                   int innovation_num2_,
++                   int newnode_id_);
++    };
++
++    class PopulationInnovations {
++        std::vector<std::vector<IndividualInnovation>> innovations;  // For holding the genetic innovations of the newest generation
++        std::map<InnovationId, std::vector<IndividualInnovation>> id2inds;
++        int cur_node_id;
++        int cur_innov_num;
++
++    public:
++        void init(int node_id, int innov_num);
++        void add(const IndividualInnovation &innov);
++        void apply();
++    };
++} // namespace NEAT
++
++#endif
+diff --git a/cpp/brain/innovgenome/innovgenome.cpp b/cpp/brain/innovgenome/innovgenome.cpp
+new file mode 100644
+index 0000000..ba25952
+--- /dev/null
++++ b/cpp/brain/innovgenome/innovgenome.cpp
+@@ -0,0 +1,1327 @@
++/*
++  Copyright 2001 The University of Texas at Austin
++
++  Licensed under the Apache License, Version 2.0 (the "License");
++  you may not use this file except in compliance with the License.
++  You may obtain a copy of the License at
++
++  http://www.apache.org/licenses/LICENSE-2.0
++
++  Unless required by applicable law or agreed to in writing, software
++  distributed under the License is distributed on an "AS IS" BASIS,
++  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++  See the License for the specific language governing permissions and
++  limitations under the License.
++*/
++#include "innovgenome.h"
++#include "protoinnovlinkgene.h"
++#include "recurrencychecker.h"
++#include "util/util.h"
++#include <assert.h>
++#include <cstring>
++
++using namespace NEAT;
++using namespace std;
++
++void InnovGenome::reset() {
++    traits.clear();
++    nodes.clear();
++    links.clear();
++}
++
++InnovGenome::InnovGenome()
++    : node_lookup(nodes) {
++}
++
++InnovGenome::InnovGenome(rng_t rng_,
++                         size_t ntraits,
++                         size_t ninputs,
++                         size_t noutputs,
++                         size_t nhidden)
++    : InnovGenome() {
++
++    rng = rng_;
++
++    for(size_t i = 0; i < ntraits; i++) {
++        traits.emplace_back(i + 1,
++                            rng.prob(),
++                            rng.prob(),
++                            rng.prob(),
++                            rng.prob(),
++                            rng.prob(),
++                            rng.prob(),
++                            rng.prob(),
++                            rng.prob(),
++                            rng.prob());
++    }
++
++    {
++        int node_id = 1;
++
++        //Bias node
++        add_node(nodes, InnovNodeGene(NT_BIAS, node_id++));
++
++        //Sensor nodes
++        for(size_t i = 0; i < ninputs; i++) {
++            add_node(nodes, InnovNodeGene(NT_SENSOR, node_id++));
++        }
++
++        //Output nodes
++        for(size_t i = 0; i < noutputs; i++) {
++            add_node(nodes, InnovNodeGene(NT_OUTPUT, node_id++));
++        }
++
++        //Hidden nodes
++        for(size_t i = 0; i < nhidden; i++) {
++            add_node(nodes, InnovNodeGene(NT_HIDDEN, node_id++));
++        }
++    }
++
++    const int node_id_bias = 1;
++    const int node_id_input = node_id_bias + 1;
++    const int node_id_output = node_id_input + ninputs;
++    const int node_id_hidden = node_id_output + noutputs;
++
++    assert(nhidden > 0);
++
++    int innov = 1;
++
++    //Create links from Bias to all hidden
++    for(size_t i = 0; i < nhidden; i++) {
++        add_link( links, InnovLinkGene(rng.element(traits).trait_id,
++                                       rng.prob(),
++                                       node_id_bias,
++                                       i + node_id_hidden,
++                                       false,
++                                       innov++,
++                                       0.0) );
++    }
++
++    //Create links from all inputs to all hidden
++    for(size_t i = 0; i < ninputs; i++) {
++        for(size_t j = 0; j < nhidden; j++) {
++            add_link( links, InnovLinkGene(rng.element(traits).trait_id,
++                                           rng.prob(),
++                                           i + node_id_input,
++                                           j + node_id_hidden,
++                                           false,
++                                           innov++,
++                                           0.0));
++        }
++    }
++
++    //Create links from all hidden to all output
++    for(size_t i = 0; i < nhidden; i++) {
++        for(size_t j = 0; j < noutputs; j++) {
++            add_link( links, InnovLinkGene(rng.element(traits).trait_id,
++                                           rng.prob(),
++                                           i + node_id_hidden,
++                                           j + node_id_output,
++                                           false,
++                                           innov++,
++                                           0.0));
++        }
++    }
++}
++
++Genome &InnovGenome::operator=(const Genome &other) {
++    return *this = dynamic_cast<const InnovGenome &>(other);
++}
++
++InnovGenome::~InnovGenome() {
++}
++
++void InnovGenome::verify() {
++#ifdef NDEBUG
++    return;
++#else
++
++    //Check for InnovNodeGenes being out of order
++    for(size_t i = 1, n = nodes.size(); i < n; i++) {
++        assert( nodes[i-1].node_id < nodes[i].node_id );
++    }
++
++    {
++        //Check links reference valid nodes.
++        for(InnovLinkGene &gene: links) {
++            assert( get_node(gene.in_node_id()) );
++            assert( get_node(gene.out_node_id()) );
++        }
++    }
++
++    //Make sure there are no duplicate genes
++    for(InnovLinkGene &gene: links) {
++        for(InnovLinkGene &gene2: links) {
++            if(&gene != &gene2) {
++                assert( (gene.is_recurrent() != gene2.is_recurrent())
++                        || (gene2.in_node_id() != gene.in_node_id())
++                        || (gene2.out_node_id() != gene.out_node_id()) );
++            }
++        }
++    }
++#endif
++}
++
++Genome::Stats InnovGenome::get_stats() {
++    return {nodes.size(), links.size()};
++}
++
++void InnovGenome::print(std::ostream &out) {
++    out<<"genomestart "<<genome_id<<std::endl;
++
++    //Output the traits
++    for(auto &t: traits)
++        t.print_to_file(out);
++
++    //Output the nodes
++    for(auto &n: nodes)
++        n.print_to_file(out);
++
++    //Output the genes
++    for(auto &g: links)
++        g.print_to_file(out);
++
++    out << "genomeend " << genome_id << std::endl;
++}
++
++int InnovGenome::get_last_node_id() {
++    return nodes.back().node_id + 1;
++}
++
++real_t InnovGenome::get_last_gene_innovnum() {
++    return links.back().innovation_num + 1;
++}
++
++void InnovGenome::duplicate_into(InnovGenome *offspring) const {
++    offspring->traits = traits;
++    offspring->links = links;
++    offspring->nodes = nodes;
++}
++
++InnovGenome &InnovGenome::operator=(const InnovGenome &other) {
++    rng = other.rng;
++    genome_id = other.genome_id;
++    traits = other.traits;
++    nodes = other.nodes;
++    links = other.links;
++    return *this;
++}
++
++void InnovGenome::mutate_random_trait() {
++    rng.element(traits).mutate(rng);
++}
++
++void InnovGenome::mutate_link_trait(int times) {
++    for(int i = 0; i < times; i++) {
++        int trait_id = 1 + rng.index(traits);
++        InnovLinkGene &gene = rng.element(links);
++
++        if(!gene.frozen) {
++            gene.set_trait_id(trait_id);
++        }
++    }
++}
++
++void InnovGenome::mutate_node_trait(int times) {
++    for(int i = 0; i < times; i++) {
++        int trait_id = 1 + rng.index(traits);
++        InnovNodeGene &node = rng.element(nodes);
++
++        if(!node.frozen) {
++            node.set_trait_id(trait_id);
++        }
++    }
++
++    //TRACK INNOVATION! - possible future use
++    //for any gene involving the mutated node, perturb that gene's
++    //mutation number
++}
++
++void InnovGenome::mutate_link_weights(real_t power,real_t rate,mutator mut_type) {
++    //Go through all the InnovLinkGenes and perturb their link's weights
++
++    real_t num = 0.0; //counts gene placement
++    real_t gene_total = (real_t)links.size();
++    real_t endpart = gene_total*0.8; //Signifies the last part of the genome
++    real_t powermod = 1.0; //Modified power by gene number
++    //The power of mutation will rise farther into the genome
++    //on the theory that the older genes are more fit since
++    //they have stood the test of time
++
++    bool severe = rng.prob() > 0.5;  //Once in a while really shake things up
++
++    //Loop on all links  (ORIGINAL METHOD)
++    for(InnovLinkGene &gene: links) {
++
++        //The following if determines the probabilities of doing cold gaussian
++        //mutation, meaning the probability of replacing a link weight with
++        //another, entirely random weight.  It is meant to bias such mutations
++        //to the tail of a genome, because that is where less time-tested links
++        //reside.  The gausspoint and coldgausspoint represent values above
++        //which a random float will signify that kind of mutation.
++
++        //Don't mutate weights of frozen links
++        if (!(gene.frozen)) {
++            real_t gausspoint;
++            real_t coldgausspoint;
++
++            if (severe) {
++                gausspoint=0.3;
++                coldgausspoint=0.1;
++            }
++            else if ((gene_total>=10.0)&&(num>endpart)) {
++                gausspoint=0.5;  //Mutate by modification % of connections
++                coldgausspoint=0.3; //Mutate the rest by replacement % of the time
++            }
++            else {
++                //Half the time don't do any cold mutations
++                if (rng.prob()>0.5) {
++                    gausspoint=1.0-rate;
++                    coldgausspoint=1.0-rate-0.1;
++                }
++                else {
++                    gausspoint=1.0-rate;
++                    coldgausspoint=1.0-rate;
++                }
++            }
++
++            //Possible methods of setting the perturbation:
++            real_t randnum = rng.posneg()*rng.prob()*power*powermod;
++            if (mut_type==GAUSSIAN) {
++                real_t randchoice = rng.prob();
++                if (randchoice > gausspoint)
++                    gene.weight()+=randnum;
++                else if (randchoice > coldgausspoint)
++                    gene.weight()=randnum;
++            }
++            else if (mut_type==COLDGAUSSIAN)
++                gene.weight()=randnum;
++
++            //Cap the weights at 8.0 (experimental)
++            if (gene.weight() > 8.0) gene.weight() = 8.0;
++            else if (gene.weight() < -8.0) gene.weight() = -8.0;
++
++            //Record the innovation
++            gene.mutation_num = gene.weight();
++
++            num+=1.0;
++        }
++
++    } //end for loop
++}
++
++void InnovGenome::mutate_toggle_enable(int times) {
++    for(int i = 0; i < times; i++) {
++        InnovLinkGene &gene = rng.element(links);
++
++        if(!gene.enable) {
++            gene.enable = true;
++        } else {
++            //We need to make sure that another gene connects out of the in-node
++            //Because if not a section of network will break off and become isolated
++            bool found = false;
++            for(InnovLinkGene &checkgene: links) {
++                if( (checkgene.in_node_id() == gene.in_node_id())
++                    && checkgene.enable
++                    && (checkgene.innovation_num != gene.innovation_num) ) {
++                    found = true;
++                    break;
++                }
++            }
++
++            //Disable the gene if it's safe to do so
++            if(found)
++                gene.enable = false;
++        }
++    }
++}
++
++void InnovGenome::mutate_gene_reenable() {
++    //Search for a disabled gene
++    for(InnovLinkGene &g: links) {
++        if(!g.enable) {
++            g.enable = true;
++            break;
++        }
++    }
++}
++
++bool InnovGenome::mutate_add_node(CreateInnovationFunc create_innov,
++                                  bool delete_split_link) {
++    InnovLinkGene *splitlink = nullptr;
++    {
++        for(int i = 0; !splitlink && i < 20; i++) {
++            InnovLinkGene &g = rng.element(links);
++            //If either the link is disabled, or it has a bias input, try again
++            if( g.enable && get_node(g.in_node_id())->type != NT_BIAS ) {
++                splitlink = &g;
++            }
++        }
++        //We couldn't find anything, so say goodbye!
++        if (!splitlink) {
++            return false;
++        }
++    }
++
++    InnovationId innov_id(splitlink->in_node_id(),
++                          splitlink->out_node_id(),
++                          splitlink->innovation_num);
++    InnovationParms innov_parms;
++
++    auto innov_apply = [this, delete_split_link, splitlink] (const Innovation *innov) {
++
++        InnovNodeGene newnode(NT_HIDDEN, innov->newnode_id);
++
++        InnovLinkGene newlink1(splitlink->trait_id(),
++                               1.0,
++                               innov->id.node_in_id,
++                               innov->newnode_id,
++                               splitlink->is_recurrent(),
++                               innov->innovation_num1,
++                               0);
++
++        InnovLinkGene newlink2(splitlink->trait_id(),
++                               splitlink->weight(),
++                               innov->newnode_id,
++                               innov->id.node_out_id,
++                               false,
++                               innov->innovation_num2,
++                               0);
++
++        if(delete_split_link) {
++            delete_link(splitlink);
++        } else {
++            splitlink->enable = false;
++        }
++
++        add_link(this->links, newlink1);
++        add_link(this->links, newlink2);
++        add_node(this->nodes, newnode);
++    };
++
++    create_innov(innov_id, innov_parms, innov_apply);
++
++    return true;
++}
++
++void InnovGenome::mutate_delete_node() {
++    size_t first_non_io;
++    for(first_non_io = 0; first_non_io < nodes.size(); first_non_io++) {
++        if( nodes[first_non_io].type == NT_HIDDEN ) {
++            break;
++        }
++    }
++
++    //Don't delete if only 0 or 1 hidden nodes
++    if(first_non_io >= (nodes.size()-1)) {
++        return;
++    }
++
++    size_t node_index = rng.index(nodes, first_non_io);
++    InnovNodeGene node = nodes[node_index];
++    assert(node.type == NT_HIDDEN);
++
++    nodes.erase(nodes.begin() + node_index);
++
++    //todo: we should have a way to look up links by in/out id
++    auto it_end = std::remove_if(links.begin(), links.end(),
++                                 [&node] (const InnovLinkGene &link) {
++                                     return link.in_node_id() == node.node_id
++                                     || link.out_node_id() == node.node_id;
++                                 });
++
++    links.resize(it_end - links.begin());
++}
++
++void InnovGenome::mutate_delete_link() {
++    if(links.size() <= 1)
++        return;
++
++    size_t link_index = rng.index(links);
++    InnovLinkGene link = links[link_index];
++    links.erase(links.begin() + link_index);
++
++    delete_if_orphaned_hidden_node(link.in_node_id());
++    delete_if_orphaned_hidden_node(link.out_node_id());
++}
++
++bool InnovGenome::mutate_add_link(CreateInnovationFunc create_innov,
++                                  int tries) {
++    InnovLinkGene *recur_checker_buf[links.size()];
++    RecurrencyChecker recur_checker(nodes.size(), links, recur_checker_buf);
++
++    InnovNodeGene *in_node = nullptr; //Pointers to the nodes
++    InnovNodeGene *out_node = nullptr; //Pointers to the nodes
++
++    //Decide whether to make this recurrent
++    bool do_recur = rng.prob() < env->recur_only_prob;
++
++    // Try to find nodes for link.
++    {
++        bool found_nodes = false;
++
++        //Find the first non-sensor so that the to-node won't look at sensors as
++        //possible destinations
++        int first_nonsensor = 0;
++        for(; is_input(nodes[first_nonsensor].get_type()); first_nonsensor++) {
++        }
++
++        for(int trycount = 0; !found_nodes && (trycount < tries); trycount++) {
++            //Here is the recurrent finder loop- it is done separately
++            if(do_recur) {
++                //Some of the time try to make a recur loop
++                // todo: make this an NE parm?
++                if (rng.prob() > 0.5) {
++                    in_node = &rng.element(nodes, first_nonsensor);
++                    out_node = in_node;
++                }
++                else {
++                    //Choose random nodenums
++                    in_node = &rng.element(nodes);
++                    out_node = &rng.element(nodes, first_nonsensor);
++                }
++            } else {
++                //Choose random nodenums
++                in_node = &rng.element(nodes);
++                out_node = &rng.element(nodes, first_nonsensor);
++            }
++
++            InnovLinkGene *existing_link = find_link(in_node->node_id, out_node->node_id, do_recur);
++            if(existing_link != nullptr) {
++                if( env->mutate_add_link_reenables ) {
++                    existing_link->enable = true;
++                    return true;
++                }
++            } else if(do_recur == recur_checker.is_recur(in_node->node_id,
++                                                         out_node->node_id)) {
++                found_nodes = true;
++            }
++        }
++
++        assert( !is_input(out_node->type) );
++
++        //Continue only if an open link was found
++        if(!found_nodes) {
++            return false;
++        }
++    }
++
++    // Create the gene.
++    {
++        InnovationId innov_id(in_node->node_id,
++                              out_node->node_id,
++                              do_recur);
++
++        //These two values may or may not take effect in the new innovation.
++        //It depends on whether this genome is the first to create the innovation,
++        //but it's impossible to know at this point who is first.
++        int trait_id = 1 + rng.index(traits);
++        real_t newweight = rng.posneg() * rng.prob() * 1.0;
++
++        InnovationParms innov_parms(newweight, trait_id);
++
++        auto innov_apply = [this] (const Innovation *innov) {
++
++            InnovLinkGene newlink(innov->parms.new_trait_id,
++                                  innov->parms.new_weight,
++                                  innov->id.node_in_id,
++                                  innov->id.node_out_id,
++                                  innov->id.recur_flag,
++                                  innov->innovation_num1,
++                                  innov->parms.new_weight);
++
++            add_link(this->links, newlink);
++        };
++
++        create_innov(innov_id, innov_parms, innov_apply);
++    }
++
++    return true;
++}
++
++void InnovGenome::add_link(vector<InnovLinkGene> &llist, const InnovLinkGene &l) {
++    auto it = std::upper_bound(llist.begin(), llist.end(), l, linklist_cmp);
++    llist.insert(it, l);
++}
++
++void InnovGenome::add_node(vector<InnovNodeGene> &nlist, const InnovNodeGene &n) {
++    auto it = std::upper_bound(nlist.begin(), nlist.end(), n, nodelist_cmp);
++    nlist.insert(it, n);
++}
++
++void InnovGenome::mate(InnovGenome *genome1,
++                       InnovGenome *genome2,
++                       InnovGenome *offspring,
++                       real_t fitness1,
++                       real_t fitness2) {
++
++    //Perform mating based on probabilities of differrent mating types
++    if( offspring->rng.prob() < env->mate_multipoint_prob ) {
++        InnovGenome::mate_multipoint(genome1,
++                                     genome2,
++                                     offspring,
++                                     fitness1,
++                                     fitness2);
++    } else {
++        InnovGenome::mate_multipoint_avg(genome1,
++                                         genome2,
++                                         offspring,
++                                         fitness1,
++                                         fitness2);
++    }
++}
++
++// todo: use NodeLookup for newnodes instead of linear search!
++void InnovGenome::mate_multipoint(InnovGenome *genome1,
++                                  InnovGenome *genome2,
++                                  InnovGenome *offspring,
++                                  real_t fitness1,
++                                  real_t fitness2) {
++    rng_t &rng = offspring->rng;
++    vector<InnovLinkGene> &links1 = genome1->links;
++    vector<InnovLinkGene> &links2 = genome2->links;
++
++    //The baby InnovGenome will contain these new Traits, InnovNodeGenes, and InnovLinkGenes
++    offspring->reset();
++    vector<Trait> &newtraits = offspring->traits;
++    vector<InnovNodeGene> &newnodes = offspring->nodes;
++    vector<InnovLinkGene> &newlinks = offspring->links;
++
++    vector<InnovLinkGene>::iterator curgene2;  //Checks for link duplication
++
++    //iterators for moving through the two parents' traits
++    vector<Trait*>::iterator p1trait;
++    vector<Trait*>::iterator p2trait;
++
++    //iterators for moving through the two parents' links
++    vector<InnovLinkGene>::iterator p1gene;
++    vector<InnovLinkGene>::iterator p2gene;
++    real_t p1innov;  //Innovation numbers for links inside parents' InnovGenomes
++    real_t p2innov;
++    vector<InnovNodeGene>::iterator curnode;  //For checking if InnovNodeGenes exist already
++
++    bool disable;  //Set to true if we want to disabled a chosen gene
++
++    disable=false;
++    InnovLinkGene newgene;
++
++    bool p1better; //Tells if the first genome (this one) has better fitness or not
++
++    bool skip;
++
++    //First, average the Traits from the 2 parents to form the baby's Traits
++    //It is assumed that trait lists are the same length
++    //In the future, may decide on a different method for trait mating
++    assert(genome1->traits.size() == genome2->traits.size());
++    for(size_t i = 0, n = genome1->traits.size(); i < n; i++) {
++        newtraits.emplace_back(genome1->traits[i], genome2->traits[i]);
++    }
++
++    //Figure out which genome is better
++    //The worse genome should not be allowed to add extra structural baggage
++    //If they are the same, use the smaller one's disjoint and excess genes only
++    if (fitness1>fitness2)
++        p1better=true;
++    else if (fitness1==fitness2) {
++        if (links1.size()<(links2.size()))
++            p1better=true;
++        else p1better=false;
++    }
++    else
++        p1better=false;
++
++    //Make sure all sensors and outputs are included
++    for(InnovNodeGene &node: genome1->nodes) {
++        if(node.type != NT_HIDDEN) {
++            //Add the new node
++            add_node(newnodes, node);
++        } else {
++            break;
++        }
++    }
++
++    //Now move through the InnovLinkGenes of each parent until both genomes end
++    p1gene = links1.begin();
++    p2gene = links2.begin();
++    while( !((p1gene==links1.end()) && (p2gene==(links2).end())) ) {
++        ProtoInnovLinkGene protogene;
++
++        skip=false;  //Default to not skipping a chosen gene
++
++        if (p1gene==links1.end()) {
++            protogene.set_gene(genome2, &*p2gene);
++            ++p2gene;
++            if (p1better) skip=true;  //Skip excess from the worse genome
++        } else if (p2gene==(links2).end()) {
++            protogene.set_gene(genome1, &*p1gene);
++            ++p1gene;
++            if (!p1better) skip=true; //Skip excess from the worse genome
++        } else {
++            //Extract current innovation numbers
++            p1innov=p1gene->innovation_num;
++            p2innov=p2gene->innovation_num;
++
++            if (p1innov==p2innov) {
++                if (rng.prob()<0.5) {
++                    protogene.set_gene(genome1, &*p1gene);
++                } else {
++                    protogene.set_gene(genome2, &*p2gene);
++                }
++
++                //If one is disabled, the corresponding gene in the offspring
++                //will likely be disabled
++                if (((p1gene->enable)==false)||
++                    ((p2gene->enable)==false))
++                    if (rng.prob()<0.75) disable=true;
++
++                ++p1gene;
++                ++p2gene;
++            } else if (p1innov < p2innov) {
++                protogene.set_gene(genome1, &*p1gene);
++                ++p1gene;
++
++                if (!p1better) skip=true;
++
++            } else if (p2innov<p1innov) {
++                protogene.set_gene(genome2, &*p2gene);
++                ++p2gene;
++
++                if (p1better) skip=true;
++            }
++        }
++
++        //Check to see if the protogene conflicts with an already chosen gene
++        //i.e. do they represent the same link
++        curgene2=newlinks.begin();
++        while ((curgene2!=newlinks.end())&&
++               (!((curgene2->in_node_id()==protogene.gene()->in_node_id())&&
++                  (curgene2->out_node_id()==protogene.gene()->out_node_id())&&(curgene2->is_recurrent()== protogene.gene()->is_recurrent()) ))&&
++               (!((curgene2->in_node_id()==protogene.gene()->out_node_id())&&
++                  (curgene2->out_node_id()==protogene.gene()->in_node_id())&&
++                  (!(curgene2->is_recurrent()))&&
++                  (!(protogene.gene()->is_recurrent())) )))
++        {
++            ++curgene2;
++        }
++
++        if (curgene2!=newlinks.end()) skip=true;  //Links conflicts, abort adding
++
++        if (!skip) {
++            //Now add the gene to the baby
++            InnovNodeGene new_inode;
++            InnovNodeGene new_onode;
++
++            //Next check for the nodes, add them if not in the baby InnovGenome already
++            InnovNodeGene *inode = protogene.in();
++            InnovNodeGene *onode = protogene.out();
++
++            //Check for inode in the newnodes list
++            if (inode->node_id<onode->node_id) {
++                //inode before onode
++
++                //Checking for inode's existence
++                curnode=newnodes.begin();
++                while((curnode!=newnodes.end())&&
++                      (curnode->node_id!=inode->node_id))
++                    ++curnode;
++
++                if (curnode==newnodes.end()) {
++                    //Here we know the node doesn't exist so we have to add it
++                    new_inode = *inode;
++                    add_node(newnodes,new_inode);
++
++                }
++                else {
++                    new_inode=*curnode;
++
++                }
++
++                //Checking for onode's existence
++                curnode=newnodes.begin();
++                while((curnode!=newnodes.end())&&
++                      (curnode->node_id!=onode->node_id))
++                    ++curnode;
++                if (curnode==newnodes.end()) {
++                    //Here we know the node doesn't exist so we have to add it
++                    new_onode = *onode;
++                    add_node(newnodes,new_onode);
++
++                }
++                else {
++                    new_onode=*curnode;
++                }
++
++            }
++            //If the onode has a higher id than the inode we want to add it first
++            else {
++                //Checking for onode's existence
++                curnode=newnodes.begin();
++                while((curnode!=newnodes.end())&&
++                      (curnode->node_id!=onode->node_id))
++                    ++curnode;
++                if (curnode==newnodes.end()) {
++                    //Here we know the node doesn't exist so we have to add it
++                    new_onode = *onode;
++                    //newnodes.push_back(new_onode);
++                    add_node(newnodes,new_onode);
++
++                }
++                else {
++                    new_onode=*curnode;
++
++                }
++
++                //Checking for inode's existence
++                curnode=newnodes.begin();
++                while((curnode!=newnodes.end())&&
++                      (curnode->node_id!=inode->node_id))
++                    ++curnode;
++                if (curnode==newnodes.end()) {
++                    //Here we know the node doesn't exist so we have to add it
++                    new_inode = *inode;
++                    add_node(newnodes,new_inode);
++                }
++                else {
++                    new_inode=*curnode;
++
++                }
++
++            } //End InnovNodeGene checking section- InnovNodeGenes are now in new InnovGenome
++
++            //Add the InnovLinkGene
++            newgene = InnovLinkGene(protogene.gene(),
++                                    protogene.gene()->trait_id(),
++                                    new_inode.node_id,
++                                    new_onode.node_id);
++            if (disable) {
++                newgene.enable=false;
++                disable=false;
++            }
++            newlinks.push_back(newgene);
++        }
++
++    }
++}
++
++// todo: use NodeLookup for newnodes instead of linear search!
++void InnovGenome::mate_multipoint_avg(InnovGenome *genome1,
++                                      InnovGenome *genome2,
++                                      InnovGenome *offspring,
++                                      real_t fitness1,
++                                      real_t fitness2) {
++    rng_t &rng = offspring->rng;
++    vector<InnovLinkGene> &links1 = genome1->links;
++    vector<InnovLinkGene> &links2 = genome2->links;
++
++    //The baby InnovGenome will contain these new Traits, InnovNodeGenes, and InnovLinkGenes
++    offspring->reset();
++    vector<Trait> &newtraits = offspring->traits;
++    vector<InnovNodeGene> &newnodes = offspring->nodes;
++    vector<InnovLinkGene> &newlinks = offspring->links;
++
++    vector<InnovLinkGene>::iterator curgene2; //Checking for link duplication
++
++    //iterators for moving through the two parents' links
++    vector<InnovLinkGene>::iterator p1gene;
++    vector<InnovLinkGene>::iterator p2gene;
++    real_t p1innov;  //Innovation numbers for links inside parents' InnovGenomes
++    real_t p2innov;
++    vector<InnovNodeGene>::iterator curnode;  //For checking if InnovNodeGenes exist already
++
++    //This InnovLinkGene is used to hold the average of the two links to be averaged
++    InnovLinkGene avgene(0,0,0,0,0,0,0);
++    InnovLinkGene newgene;
++
++    bool skip;
++
++    bool p1better;  //Designate the better genome
++
++    //First, average the Traits from the 2 parents to form the baby's Traits
++    //It is assumed that trait lists are the same length
++    //In future, could be done differently
++    for(size_t i = 0, n = genome1->traits.size(); i < n; i++) {
++        newtraits.emplace_back(genome1->traits[i], genome2->traits[i]);
++    }
++
++    //NEW 3/17/03 Make sure all sensors and outputs are included
++    for(InnovNodeGene &node: genome1->nodes) {
++        if(node.type != NT_HIDDEN) {
++            add_node(newnodes, node);
++        } else {
++            break;
++        }
++    }
++
++    //Figure out which genome is better
++    //The worse genome should not be allowed to add extra structural baggage
++    //If they are the same, use the smaller one's disjoint and excess genes only
++    if (fitness1>fitness2)
++        p1better=true;
++    else if (fitness1==fitness2) {
++        if (links1.size()<(links2.size()))
++            p1better=true;
++        else p1better=false;
++    }
++    else
++        p1better=false;
++
++
++    //Now move through the InnovLinkGenes of each parent until both genomes end
++    p1gene=links1.begin();
++    p2gene=links2.begin();
++    while(!((p1gene==links1.end()) && (p2gene==(links2).end()))) {
++        ProtoInnovLinkGene protogene;
++
++        avgene.enable=true;  //Default to enabled
++
++        skip=false;
++
++        if (p1gene==links1.end()) {
++            protogene.set_gene(genome2, &*p2gene);
++            ++p2gene;
++
++            if (p1better) skip=true;
++
++        }
++        else if (p2gene==(links2).end()) {
++            protogene.set_gene(genome1, &*p1gene);
++            ++p1gene;
++
++            if (!p1better) skip=true;
++        }
++        else {
++            //Extract current innovation numbers
++            p1innov=p1gene->innovation_num;
++            p2innov=p2gene->innovation_num;
++
++            if (p1innov==p2innov) {
++                protogene.set_gene(nullptr, &avgene);
++
++                //Average them into the avgene
++                if (rng.prob()>0.5) {
++                    avgene.set_trait_id(p1gene->trait_id());
++                } else {
++                    avgene.set_trait_id(p2gene->trait_id());
++                }
++
++                //WEIGHTS AVERAGED HERE
++                avgene.weight() = (p1gene->weight()+p2gene->weight())/2.0;
++
++                if(rng.prob() > 0.5) {
++                    protogene.set_in(genome1->get_node(p1gene->in_node_id()));
++                } else {
++                    protogene.set_in(genome2->get_node(p2gene->in_node_id()));
++                }
++
++                if(rng.prob() > 0.5) {
++                    protogene.set_out(genome1->get_node(p1gene->out_node_id()));
++                } else {
++                    protogene.set_out(genome2->get_node(p2gene->out_node_id()));
++                }
++
++                if (rng.prob()>0.5) avgene.set_recurrent(p1gene->is_recurrent());
++                else avgene.set_recurrent(p2gene->is_recurrent());
++
++                avgene.innovation_num=p1gene->innovation_num;
++                avgene.mutation_num=(p1gene->mutation_num+p2gene->mutation_num)/2.0;
++
++                if (((p1gene->enable)==false)||
++                    ((p2gene->enable)==false))
++                    if (rng.prob()<0.75) avgene.enable=false;
++
++                ++p1gene;
++                ++p2gene;
++            } else if (p1innov<p2innov) {
++                protogene.set_gene(genome1, &*p1gene);
++                ++p1gene;
++
++                if (!p1better) skip=true;
++            } else if (p2innov<p1innov) {
++                protogene.set_gene(genome2, &*p2gene);
++                ++p2gene;
++
++                if (p1better) skip=true;
++            }
++        }
++
++        //Check to see if the chosengene conflicts with an already chosen gene
++        //i.e. do they represent the same link
++        curgene2=newlinks.begin();
++        while ((curgene2!=newlinks.end()))
++
++        {
++
++            if (((curgene2->in_node_id()==protogene.gene()->in_node_id())&&
++                 (curgene2->out_node_id()==protogene.gene()->out_node_id())&&
++                 (curgene2->is_recurrent()== protogene.gene()->is_recurrent()))||
++                ((curgene2->out_node_id()==protogene.gene()->in_node_id())&&
++                 (curgene2->in_node_id()==protogene.gene()->out_node_id())&&
++                 (!(curgene2->is_recurrent()))&&
++                 (!(protogene.gene()->is_recurrent()))     ))
++            {
++                skip=true;
++
++            }
++            ++curgene2;
++        }
++
++        if (!skip) {
++            //Now add the chosengene to the baby
++
++            //Next check for the nodes, add them if not in the baby InnovGenome already
++            InnovNodeGene *inode = protogene.in();
++            InnovNodeGene *onode = protogene.out();
++
++            //Check for inode in the newnodes list
++            InnovNodeGene new_inode;
++            InnovNodeGene new_onode;
++            if (inode->node_id<onode->node_id) {
++
++                //Checking for inode's existence
++                curnode=newnodes.begin();
++                while((curnode!=newnodes.end())&&
++                      (curnode->node_id!=inode->node_id))
++                    ++curnode;
++
++                if (curnode==newnodes.end()) {
++                    //Here we know the node doesn't exist so we have to add it
++                    new_inode = *inode;
++                    add_node(newnodes,new_inode);
++                }
++                else {
++                    new_inode=(*curnode);
++
++                }
++
++                //Checking for onode's existence
++                curnode=newnodes.begin();
++                while((curnode!=newnodes.end())&&
++                      (curnode->node_id!=onode->node_id))
++                    ++curnode;
++                if (curnode==newnodes.end()) {
++                    //Here we know the node doesn't exist so we have to add it
++                    new_onode = *onode;
++
++                    add_node(newnodes,new_onode);
++                }
++                else {
++                    new_onode=(*curnode);
++                }
++            }
++            //If the onode has a higher id than the inode we want to add it first
++            else {
++                //Checking for onode's existence
++                curnode=newnodes.begin();
++                while((curnode!=newnodes.end())&&
++                      (curnode->node_id!=onode->node_id))
++                    ++curnode;
++                if (curnode==newnodes.end()) {
++                    //Here we know the node doesn't exist so we have to add it
++                    new_onode = *onode;
++
++                    add_node(newnodes,new_onode);
++                }
++                else {
++                    new_onode=(*curnode);
++                }
++
++                //Checking for inode's existence
++                curnode=newnodes.begin();
++                while((curnode!=newnodes.end())&&
++                      (curnode->node_id!=inode->node_id))
++                    ++curnode;
++                if (curnode==newnodes.end()) {
++                    //Here we know the node doesn't exist so we have to add it
++                    new_inode = *inode;
++
++                    add_node(newnodes,new_inode);
++                }
++                else {
++                    new_inode=(*curnode);
++
++                }
++
++            } //End InnovNodeGene checking section- InnovNodeGenes are now in new InnovGenome
++
++            //Add the InnovLinkGene
++            newgene = InnovLinkGene(protogene.gene(),
++                                    protogene.gene()->trait_id(),
++                                    new_inode.node_id,
++                                    new_onode.node_id);
++
++            newlinks.push_back(newgene);
++
++        }  //End if which checked for link duplicationb
++
++    }
++}
++
++real_t InnovGenome::compatibility(InnovGenome *g) {
++    vector<InnovLinkGene> &links1 = this->links;
++    vector<InnovLinkGene> &links2 = g->links;
++
++
++    //Innovation numbers
++    real_t p1innov;
++    real_t p2innov;
++
++    //Intermediate value
++    real_t mut_diff;
++
++    //Set up the counters
++    real_t num_disjoint=0.0;
++    real_t num_excess=0.0;
++    real_t mut_diff_total=0.0;
++    real_t num_matching=0.0;  //Used to normalize mutation_num differences
++
++    //Now move through the InnovLinkGenes of each potential parent
++    //until both InnovGenomes end
++    vector<InnovLinkGene>::iterator p1gene = links1.begin();
++    vector<InnovLinkGene>::iterator p2gene = links2.begin();
++
++    while(!((p1gene==links1.end())&&
++            (p2gene==links2.end()))) {
++
++        if (p1gene==links1.end()) {
++            ++p2gene;
++            num_excess+=1.0;
++        }
++        else if (p2gene==links2.end()) {
++            ++p1gene;
++            num_excess+=1.0;
++        }
++        else {
++            //Extract current innovation numbers
++            p1innov = p1gene->innovation_num;
++            p2innov = p2gene->innovation_num;
++
++            if (p1innov==p2innov) {
++                num_matching+=1.0;
++                mut_diff = p1gene->mutation_num - p2gene->mutation_num;
++                if (mut_diff<0.0) mut_diff=0.0-mut_diff;
++                mut_diff_total+=mut_diff;
++
++                ++p1gene;
++                ++p2gene;
++            }
++            else if (p1innov<p2innov) {
++                ++p1gene;
++                num_disjoint+=1.0;
++            }
++            else if (p2innov<p1innov) {
++                ++p2gene;
++                num_disjoint+=1.0;
++            }
++        }
++    } //End while
++
++    //Return the compatibility number using compatibility formula
++    //Note that mut_diff_total/num_matching gives the AVERAGE
++    //difference between mutation_nums for any two matching InnovLinkGenes
++    //in the InnovGenome
++
++    //Normalizing for genome size
++    //return (disjoint_coeff*(num_disjoint/max_genome_size)+
++    //  excess_coeff*(num_excess/max_genome_size)+
++    //  mutdiff_coeff*(mut_diff_total/num_matching));
++
++
++    //Look at disjointedness and excess in the absolute (ignoring size)
++
++    return (env->disjoint_coeff*(num_disjoint/1.0)+
++            env->excess_coeff*(num_excess/1.0)+
++            env->mutdiff_coeff*(mut_diff_total/num_matching));
++}
++
++real_t InnovGenome::trait_compare(Trait *t1,Trait *t2) {
++
++    int id1=t1->trait_id;
++    int id2=t2->trait_id;
++    int count;
++    real_t params_diff=0.0; //Measures parameter difference
++
++    //See if traits represent different fundamental types of connections
++    if ((id1==1)&&(id2>=2)) {
++        return 0.5;
++    }
++    else if ((id2==1)&&(id1>=2)) {
++        return 0.5;
++    }
++    //Otherwise, when types are same, compare the actual parameters
++    else {
++        if (id1>=2) {
++            for (count=0;count<=2;count++) {
++                params_diff += fabs(t1->params[count]-t2->params[count]);
++            }
++            return params_diff/4.0;
++        }
++        else return 0.0; //For type 1, params are not applicable
++    }
++
++}
++
++void InnovGenome::randomize_traits() {
++    for(InnovNodeGene &node: nodes) {
++        node.set_trait_id(1 + rng.index(traits));
++    }
++
++    for(InnovLinkGene &gene: links) {
++        gene.set_trait_id(1 + rng.index(traits));
++    }
++}
++
++inline Trait &get_trait(vector<Trait> &traits, int trait_id) {
++    Trait &t = traits[trait_id - 1];
++    assert(t.trait_id == trait_id);
++    return t;
++}
++
++Trait &InnovGenome::get_trait(const InnovNodeGene &node) {
++    return ::get_trait(traits, node.get_trait_id());
++}
++
++Trait &InnovGenome::get_trait(const InnovLinkGene &gene) {
++    return ::get_trait(traits, gene.trait_id());
++}
++
++void InnovGenome::init_phenotype(Network &net) {
++    size_t nnodes = nodes.size();
++    assert(nnodes <= NODES_MAX);
++
++    //---
++    //--- Count how many of each type of node.
++    //---
++    NetDims dims;
++    std::memset(&dims, 0, sizeof(dims));
++
++    for(size_t i = 0; i < nnodes; i++) {
++        InnovNodeGene &node = nodes[i];
++
++        switch(node.type) {
++        case NT_BIAS:
++            dims.nnodes.bias++;
++            break;
++        case NT_SENSOR:
++            dims.nnodes.sensor++;
++            break;
++        case NT_OUTPUT:
++            dims.nnodes.output++;
++            break;
++        case NT_HIDDEN:
++            dims.nnodes.hidden++;
++            break;
++        default:
++            panic();
++        }
++    }
++    dims.nnodes.all = nnodes;
++    dims.nnodes.input = dims.nnodes.bias + dims.nnodes.sensor;
++    dims.nnodes.noninput = dims.nnodes.output + dims.nnodes.hidden;
++
++    //---
++    //--- Create unsorted array of links, converting node ID to index in process.
++    //---
++    NetLink netlinks[links.size()];
++    size_t nlinks = 0;
++    size_t node_nlinks[nnodes];
++    memset(node_nlinks, 0, sizeof(size_t) * nnodes);
++
++    for(InnovLinkGene &link: links) {
++        if(link.enable) {
++            NetLink &netlink = netlinks[nlinks++];
++
++            netlink.weight = link.weight();
++            netlink.in_node_index = get_node_index(link.in_node_id());
++            netlink.out_node_index = get_node_index(link.out_node_id());
++
++            node_nlinks[netlink.out_node_index]++;
++        }
++    }
++    assert(nlinks <= LINKS_MAX);
++
++    dims.nlinks = nlinks;
++
++    //---
++    //--- Determine layout of links for each node in sorted array
++    //---
++    NetNode netnodes[nnodes];
++    netnodes[0].incoming_start = 0;
++    netnodes[0].incoming_end = node_nlinks[0];
++    for(size_t i = 1; i < nnodes; i++) {
++        NetNode &prev = netnodes[i-1];
++        NetNode &curr = netnodes[i];
++
++        curr.incoming_start = prev.incoming_end;
++        curr.incoming_end = curr.incoming_start + node_nlinks[i];
++    }
++    assert(netnodes[nnodes - 1].incoming_end == nlinks);
++
++    //---
++    //--- Create sorted links
++    //---
++    memset(node_nlinks, 0, sizeof(size_t) * nnodes);
++    NetLink netlinks_sorted[nlinks];
++    for(size_t i = 0; i < nlinks; i++) {
++        NetLink &netlink = netlinks[i];
++        size_t inode = netlink.out_node_index;
++        size_t isorted = netnodes[inode].incoming_start + node_nlinks[inode]++;
++        netlinks_sorted[isorted] = netlink;
++    }
++
++    //---
++    //--- Configure the net
++    //---
++    net.configure(dims, netnodes, netlinks_sorted);
++}
++
++InnovLinkGene *InnovGenome::find_link(int in_node_id, int out_node_id, bool is_recurrent) {
++    for(InnovLinkGene &g: links) {
++        if( (g.in_node_id() == in_node_id)
++            && (g.out_node_id() == out_node_id)
++            && (g.is_recurrent() == is_recurrent) ) {
++
++            return &g;
++        }
++    }
++
++    return nullptr;
++}
++
++InnovNodeGene *InnovGenome::get_node(int id) {
++    return node_lookup.find(id);
++}
++
++node_size_t InnovGenome::get_node_index(int id) {
++    node_size_t i = get_node(id) - nodes.data();
++    assert(nodes[i].node_id == id);
++    return i;
++}
++
++void InnovGenome::delete_if_orphaned_hidden_node(int node_id) {
++    InnovNodeGene *node = get_node(node_id);
++    if( (node == nullptr) || (node->type != NT_HIDDEN) )
++        return;
++
++    bool found_link;
++    for(InnovLinkGene &link: links) {
++        if(link.in_node_id() == node_id || link.out_node_id() == node_id) {
++            found_link = true;
++            break;
++        }
++    }
++
++    if(!found_link) {
++        auto iterator = nodes.begin() + (node - nodes.data());
++        assert(iterator->node_id == node_id);
++        nodes.erase(iterator);
++    }
++}
++
++void InnovGenome::delete_link(InnovLinkGene *link) {
++    auto iterator = find_if(links.begin(), links.end(),
++                            [link](const InnovLinkGene &l) {
++                                return l.innovation_num == link->innovation_num;
++                            });
++    assert(iterator != links.end());
++    links.erase(iterator);
++}
+diff --git a/cpp/brain/innovgenome/innovgenome.h b/cpp/brain/innovgenome/innovgenome.h
+new file mode 100644
+index 0000000..e6d9447
+--- /dev/null
++++ b/cpp/brain/innovgenome/innovgenome.h
+@@ -0,0 +1,117 @@
++/*
++ Copyright 2001 The University of Texas at Austin
++
++   Licensed under the Apache License, Version 2.0 (the "License");
++   you may not use this file except in compliance with the License.
++   You may obtain a copy of the License at
++
++       http://www.apache.org/licenses/LICENSE-2.0
++
++   Unless required by applicable law or agreed to in writing, software
++   distributed under the License is distributed on an "AS IS" BASIS,
++   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++   See the License for the specific language governing permissions and
++   limitations under the License.
++*/
++#pragma once
++
++#include "genome.h"
++#include "innovlinkgene.h"
++#include "innovnodegene.h"
++#include "innovnodelookup.h"
++#include "innovation.h"
++
++namespace NEAT {
++
++    class InnovGenome : public Genome {
++    public:
++        std::vector<InnovNodeGene> nodes;
++        std::vector<InnovLinkGene> links;
++
++        int get_last_node_id(); //Return id of final InnovNodeGene in InnovGenome
++        real_t get_last_gene_innovnum(); //Return last innovation number in InnovGenome
++
++        InnovGenome();
++        InnovGenome(rng_t rng,
++                    size_t ntraits,
++                    size_t ninputs,
++                    size_t noutputs,
++                    size_t nhidden);
++
++        virtual Genome &operator=(const Genome &other) override;
++
++        //Destructor kills off all lists (including the trait vector)
++        virtual ~InnovGenome();
++
++        void duplicate_into(InnovGenome *offspring) const;
++        InnovGenome &operator=(const InnovGenome &other);
++
++        // For debugging: A number of tests can be run on a genome to check its
++        // integrity
++        // Note: Some of these tests do not indicate a bug, but rather are meant
++        // to be used to detect specific system states
++        virtual void verify() override;
++        virtual Stats get_stats() override;
++
++        // ******* MUTATORS *******
++
++        // Change random node's trait times times
++        void mutate_node_trait(int times);
++
++        // Add Gaussian noise to linkweights either GAUSSIAN or COLDGAUSSIAN (from zero)
++        void mutate_link_weights(real_t power,real_t rate,mutator mut_type);
++
++
++        // ****** MATING METHODS *****
++        static void mate(InnovGenome *genome1,
++                         InnovGenome *genome2,
++                         InnovGenome *offspring,
++                         real_t fitness1,
++                         real_t fitness2);
++
++        // ******** COMPATIBILITY CHECKING METHODS ********
++
++        // This function gives a measure of compatibility between
++        //   two InnovGenomes by computing a linear combination of 3
++        //   characterizing variables of their compatibilty.
++        //   The 3 variables represent PERCENT DISJOINT GENES,
++        //   PERCENT EXCESS GENES, MUTATIONAL DIFFERENCE WITHIN
++        //   MATCHING GENES.  So the formula for compatibility
++        //   is:  disjoint_coeff*pdg+excess_coeff*peg+mutdiff_coeff*mdmg.
++        //   The 3 coefficients are global system parameters
++        real_t compatibility(InnovGenome *g);
++
++        real_t trait_compare(Trait *t1,Trait *t2);
++
++        // Randomize the trait pointers of all the node and connection genes
++        void randomize_traits();
++
++        Trait &get_trait(const InnovNodeGene &node);
++        Trait &get_trait(const InnovLinkGene &gene);
++
++        InnovNodeGene *get_node(int id);
++        node_size_t get_node_index(int id);
++
++        virtual void init_phenotype(class Network &net) override;
++
++    public:
++        void reset();
++
++        static bool linklist_cmp(const InnovLinkGene &a, const InnovLinkGene &b) {
++            return a.innovation_num < b.innovation_num;
++        }
++
++        //Inserts a InnovNodeGene into a given ordered list of InnovNodeGenes in order
++        static void add_node(std::vector<InnovNodeGene> &nlist, const InnovNodeGene &n);
++
++        //Adds a new gene that has been created through a mutation in the
++        //*correct order* into the list of links in the genome
++        static void add_link(std::vector<InnovLinkGene> &glist, const InnovLinkGene &g);
++
++    private:
++        InnovLinkGene *find_link(int in_node_id, int out_node_id, bool is_recurrent);
++	
++        InnovNodeLookup node_lookup;
++    };
++}
++
+diff --git a/cpp/brain/innovgenome/innovgenomemanager.cpp b/cpp/brain/innovgenome/innovgenomemanager.cpp
+new file mode 100644
+index 0000000..a7b5f2e
+--- /dev/null
++++ b/cpp/brain/innovgenome/innovgenomemanager.cpp
+@@ -0,0 +1,265 @@
++#include "innovgenome.h"
++#include "innovgenomemanager.h"
++#include "util/util.h"
++#include <memory>
++
++using namespace NEAT;
++
++/* Colin's values
++#define MAX_COMPLEXIFY_PHASE_DURATION 100
++#define MAX_PRUNE_PHASE_DURATION 0.3
++*/
++#define MAX_COMPLEXIFY_PHASE_DURATION 40
++#define PRUNE_PHASE_FACTOR 0.5
++
++InnovGenomeManager::InnovGenomeManager() {
++    if(env->search_type == GeneticSearchType::PHASED) {
++        search_phase = COMPLEXIFY;
++        search_phase_start = 1;
++        max_phase_duration = MAX_COMPLEXIFY_PHASE_DURATION;
++    } else {
++        search_phase = UNDEFINED;
++        search_phase_start = -1;
++        max_phase_duration = 0;
++    }
++    generation = 1;
++}
++
++InnovGenomeManager::~InnovGenomeManager() {
++}
++
++static InnovGenome *to_innov(Genome &g) {
++    return dynamic_cast<InnovGenome *>(&g);
++}
++
++std::unique_ptr<Genome> InnovGenomeManager::make_default() {
++    return std::unique_ptr<Genome>(new InnovGenome());
++}
++
++std::vector<std::unique_ptr<Genome>> InnovGenomeManager::create_seed_generation(size_t ngenomes,
++                                                                      rng_t rng,
++                                                                      size_t ntraits,
++                                                                      size_t ninputs,
++                                                                      size_t noutputs,
++                                                                      size_t nhidden) {
++    InnovGenome start_genome(rng,
++                             ntraits,
++                             ninputs,
++                             noutputs,
++                             nhidden);
++
++    std::vector<std::unique_ptr<Genome>> genomes;
++    {
++        rng_t _rng = rng;
++        for(int i = 0; i < env->pop_size; i++) {
++            InnovGenome *g = new InnovGenome();
++            start_genome.duplicate_into(g);
++            g->rng.seed(_rng.integer());
++            g->mutate_link_weights(1.0,1.0,COLDGAUSSIAN);
++            g->randomize_traits();
++
++            genomes.emplace_back(std::unique_ptr<Genome>(g));
++        }
++    }
++
++    {
++        InnovGenome *g = to_innov(*genomes.back());
++
++        //Keep a record of the innovation and node number we are on
++        innovations.init(g->get_last_node_id(),
++                         g->get_last_gene_innovnum());
++    }
++
++    return genomes;
++}
++
++bool InnovGenomeManager::are_compatible(Genome &genome1,
++                                        Genome &genome2) {
++    return to_innov(genome1)->compatibility(to_innov(genome2)) < env->compat_threshold;
++}
++
++void InnovGenomeManager::clone(Genome &orig,
++                               Genome &clone) {
++    to_innov(orig)->duplicate_into(to_innov(clone));
++}
++
++void InnovGenomeManager::mate(Genome &genome1,
++                              Genome &genome2,
++                              Genome &offspring,
++                              real_t fitness1,
++                              real_t fitness2) {
++
++    if(!is_mate_allowed()) {
++        if(fitness1 > fitness2) {
++            clone(genome1, offspring);
++        } else {
++            clone(genome2, offspring);
++        }
++        mutate(offspring, MUTATE_OP_ANY);
++    } else {
++        InnovGenome::mate(to_innov(genome1),
++                          to_innov(genome2),
++                          to_innov(offspring),
++                          fitness1,
++                          fitness2);
++
++        //Determine whether to mutate the baby's InnovGenome
++        //This is done randomly or if the genome1 and genome2 are the same organism
++        if( !offspring.rng.under(env->mate_only_prob) ||
++            (genome2.genome_id == genome1.genome_id) ||
++            (to_innov(genome2)->compatibility(to_innov(genome1)) == 0.0) ) {
++
++            mutate(offspring, MUTATE_OP_ANY);
++        }
++    }
++}
++
++void InnovGenomeManager::mutate(Genome &genome_,
++                                MutationOperation op) {
++    InnovGenome *genome = to_innov(genome_);
++    bool allow_del = is_delete_allowed();
++    bool allow_add = is_add_allowed();
++
++    switch(op) {
++    case MUTATE_OP_WEIGHTS:
++        genome->mutate_link_weights(env->weight_mut_power,
++                                    1.0,
++                                    GAUSSIAN);
++        break;
++    case MUTATE_OP_STRUCTURE: {
++        if(!allow_add && !allow_del) {
++            mutate(genome_, MUTATE_OP_WEIGHTS);
++        } else {
++            if(!allow_del || genome_.rng.boolean()) {
++                genome->mutate_add_link(create_innov_func(genome_),
++                                        env->newlink_tries);
++            } else {
++                genome->mutate_delete_link();
++            }
++        }
++    } break;
++    case MUTATE_OP_ANY: {
++        rng_t &rng = genome->rng;
++        rng_t::prob_switch_t op = rng.prob_switch();
++
++        if( allow_add && op.prob_case(env->mutate_add_node_prob) ) {
++            bool delete_split_link = env->search_type != GeneticSearchType::COMPLEXIFY;
++            genome->mutate_add_node(create_innov_func(genome_), delete_split_link);
++        } else if( allow_add && op.prob_case(env->mutate_add_link_prob) ) {
++            genome->mutate_add_link(create_innov_func(genome_),
++                                    env->newlink_tries);
++        } else if( allow_del && op.prob_case(env->mutate_delete_link_prob) ) {
++            genome->mutate_delete_link();
++        } else if( allow_del && op.prob_case(env->mutate_delete_node_prob) ) {
++            genome->mutate_delete_node();
++        } else {
++            //Only do other mutations when not doing sturctural mutations
++            if( rng.under(env->mutate_random_trait_prob) ) {
++                genome->mutate_random_trait();
++            }
++            if( rng.under(env->mutate_link_trait_prob) ) {
++                genome->mutate_link_trait(1);
++            }
++            if( rng.under(env->mutate_node_trait_prob) ) {
++                genome->mutate_node_trait(1);
++            }
++            if( rng.under(env->mutate_link_weights_prob) ) {
++                genome->mutate_link_weights(env->weight_mut_power,
++                                            1.0,
++                                            GAUSSIAN);
++            }
++
++            if(env->search_type == GeneticSearchType::COMPLEXIFY) {
++                if( rng.under(env->mutate_toggle_enable_prob) ) {
++                    genome->mutate_toggle_enable(1);
++                }
++                if (rng.under(env->mutate_gene_reenable_prob) ) {
++                    genome->mutate_gene_reenable();
++                }
++            }
++        }
++    } break;
++    default:
++        panic();
++    }
++
++    if(genome->links.size() == 0) {
++        genome->mutate_add_link(create_innov_func(genome_),
++                                env->newlink_tries);
++    }
++}
++
++void InnovGenomeManager::finalize_generation(bool new_fittest) {
++    innovations.apply();
++
++    generation++;
++    if(env->search_type == GeneticSearchType::PHASED) {
++        int phase_duration = generation - search_phase_start;
++        switch(search_phase) {
++        case COMPLEXIFY:
++            if( (phase_duration >= max_phase_duration)
++                || new_fittest) {
++                std::cout << "phase PRUNE @ gen " << generation << std::endl;
++                search_phase_start = generation;
++                search_phase = PRUNE;
++                max_phase_duration = 1 + int(PRUNE_PHASE_FACTOR * phase_duration);
++            }
++            break;
++        case PRUNE:
++            if(phase_duration >= max_phase_duration) {
++                std::cout << "phase COMPLEXIFY @ gen " << generation << std::endl;
++                search_phase_start = generation;
++                search_phase = COMPLEXIFY;
++                max_phase_duration = MAX_COMPLEXIFY_PHASE_DURATION;
++            }
++            break;
++        default:
++            panic();
++        }
++    }
++}
++
++CreateInnovationFunc InnovGenomeManager::create_innov_func(Genome &g) {
++    return [this, &g] (InnovationId id,
++                       InnovationParms parms,
++                       IndividualInnovation::ApplyFunc apply) {
++        innovations.add(IndividualInnovation(g.genome_id, id, parms, apply));
++    };
++}
++
++bool InnovGenomeManager::is_mate_allowed() {
++    switch(env->search_type) {
++    case GeneticSearchType::PHASED:
++        return search_phase == COMPLEXIFY;
++    case GeneticSearchType::BLENDED:
++    case GeneticSearchType::COMPLEXIFY:
++        return true;
++    default:
++        panic();
++    }
++}
++
++bool InnovGenomeManager::is_add_allowed() {
++    switch(env->search_type) {
++    case GeneticSearchType::PHASED:
++        return search_phase == COMPLEXIFY;
++    case GeneticSearchType::BLENDED:
++    case GeneticSearchType::COMPLEXIFY:
++        return true;
++    default:
++        panic();
++    }
++}
++
++bool InnovGenomeManager::is_delete_allowed() {
++    switch(env->search_type) {
++    case GeneticSearchType::PHASED:
++        return search_phase == PRUNE;
++    case GeneticSearchType::BLENDED:
++        return true;
++    case GeneticSearchType::COMPLEXIFY:
++        return false;
++    default:
++        panic();
++    }
++}
+diff --git a/cpp/brain/innovgenome/innovgenomemanager.h b/cpp/brain/innovgenome/innovgenomemanager.h
+new file mode 100644
+index 0000000..ce66dcd
+--- /dev/null
++++ b/cpp/brain/innovgenome/innovgenomemanager.h
+@@ -0,0 +1,59 @@
++#pragma once
++
++#include "genomemanager.h"
++#include "innovation.h"
++
++namespace NEAT {
++
++    class InnovGenomeManager : public GenomeManager {
++        friend class GenomeManager;
++    protected:
++        InnovGenomeManager();
++    public:
++        virtual ~InnovGenomeManager();
++
++        virtual std::unique_ptr<Genome> make_default() override;
++
++        virtual std::vector<std::unique_ptr<Genome>> create_seed_generation(size_t ngenomes,
++                                                                            class rng_t rng,
++                                                                            size_t ntraits,
++                                                                            size_t ninputs,
++                                                                            size_t noutputs,
++                                                                            size_t nhidden) override;
++
++        virtual bool are_compatible(Genome &genome1,
++                                    Genome &genome2) override;
++
++        virtual void clone(Genome &orig,
++                           Genome &clone) override;
++
++        virtual void mate(Genome &genome1,
++                          Genome &genome2,
++                          Genome &offspring,
++                          real_t fitness1,
++                          real_t fitness2) override;
++
++        virtual void mutate(Genome &genome,
++                            MutationOperation op = MUTATE_OP_ANY) override;
++
++        virtual void finalize_generation(bool new_fittest) override;
++
++    protected:
++        CreateInnovationFunc create_innov_func(Genome &g);
++        bool is_mate_allowed();
++        bool is_add_allowed();
++        bool is_delete_allowed();
++
++        PopulationInnovations innovations;
++
++        int generation;
++        enum SearchPhase {
++            UNDEFINED,
++            COMPLEXIFY,
++            PRUNE
++        } search_phase;
++        int search_phase_start;
++        int max_phase_duration;
++    };
++
++}
+diff --git a/cpp/brain/innovgenome/innovlinkgene.cpp b/cpp/brain/innovgenome/innovlinkgene.cpp
+new file mode 100644
+index 0000000..18968a3
+--- /dev/null
++++ b/cpp/brain/innovgenome/innovlinkgene.cpp
+@@ -0,0 +1,129 @@
++/*
++  Copyright 2001 The University of Texas at Austin
++
++  Licensed under the Apache License, Version 2.0 (the "License");
++  you may not use this file except in compliance with the License.
++  You may obtain a copy of the License at
++
++  http://www.apache.org/licenses/LICENSE-2.0
++
++  Unless required by applicable law or agreed to in writing, software
++  distributed under the License is distributed on an "AS IS" BASIS,
++  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++  See the License for the specific language governing permissions and
++  limitations under the License.
++*/
++#include "innovlinkgene.h"
++#include <sstream>
++
++using namespace NEAT;
++
++InnovLinkGene::InnovLinkGene(real_t w,
++                             int inode_id,
++                             int onode_id,
++                             bool recur,
++                             int innov,
++                             real_t mnum) {
++    _weight = w;
++    _in_node_id = inode_id;
++    _out_node_id = onode_id;
++    _is_recurrent = recur;
++    _trait_id = 1;
++
++    innovation_num = innov;
++    mutation_num = mnum;
++    enable = true;
++    frozen = false;
++}
++
++
++//Construct a gene with a trait
++InnovLinkGene::InnovLinkGene(int trait_id,
++                             real_t w,
++                             int inode_id,
++                             int onode_id,
++                             bool recur,
++                             int innov,
++                             real_t mnum) {
++    _weight = w;
++    _in_node_id = inode_id;
++    _out_node_id = onode_id;
++    _is_recurrent = recur;
++    _trait_id = trait_id;
++
++    innovation_num=innov;
++    mutation_num=mnum;
++    enable=true;
++    frozen=false;
++}
++
++InnovLinkGene::InnovLinkGene(InnovLinkGene *g,
++                             int trait_id,
++                             int inode_id,
++                             int onode_id) {
++    _weight = g->_weight;
++    _in_node_id = inode_id;
++    _out_node_id = onode_id;
++    _is_recurrent = g->_is_recurrent;
++    _trait_id = trait_id;
++
++    innovation_num=g->innovation_num;
++    mutation_num=g->mutation_num;
++    enable=g->enable;
++
++    frozen=g->frozen;
++}
++
++//todo: use NodeLookup
++InnovLinkGene::InnovLinkGene(const char *argline) {
++    //InnovLinkGene parameter holders
++    int trait_id;
++    int inodenum;
++    int onodenum;
++    real_t weight;
++    int recur;
++
++    //Get the gene parameters
++    std::stringstream ss(argline);
++    ss >> trait_id >> inodenum >> onodenum >> weight >> recur >> innovation_num >> mutation_num >> enable;
++
++    frozen=false; //TODO: MAYBE CHANGE
++
++    _weight = weight;
++    _in_node_id = inodenum;
++    _out_node_id = onodenum;
++    _is_recurrent = recur;
++    _trait_id = trait_id;
++}
++
++InnovLinkGene::InnovLinkGene(const InnovLinkGene& gene)
++{
++    innovation_num = gene.innovation_num;
++    mutation_num = gene.mutation_num;
++    enable = gene.enable;
++    frozen = gene.frozen;
++
++    _weight = gene._weight;
++    _in_node_id = gene._in_node_id;
++    _out_node_id = gene._out_node_id;
++    _is_recurrent = gene._is_recurrent;
++    _trait_id = gene._trait_id;
++}
++
++InnovLinkGene::~InnovLinkGene() {
++}
++
++
++void InnovLinkGene::print_to_file(std::ostream &outFile) {
++    outFile<<"gene ";
++
++    //Start off with the trait number for this gene
++    outFile << _trait_id << " ";
++    outFile << _in_node_id << " ";
++    outFile << _out_node_id << " ";
++    outFile << _weight << " ";
++    outFile << _is_recurrent << " ";
++    outFile << innovation_num << " ";
++    outFile << mutation_num << " ";
++    outFile << enable << std::endl;
++}
+diff --git a/cpp/brain/innovgenome/innovlinkgene.h b/cpp/brain/innovgenome/innovlinkgene.h
+new file mode 100644
+index 0000000..9f0ee74
+--- /dev/null
++++ b/cpp/brain/innovgenome/innovlinkgene.h
+@@ -0,0 +1,94 @@
++/*
++ Copyright 2001 The University of Texas at Austin
++
++   Licensed under the Apache License, Version 2.0 (the "License");
++   you may not use this file except in compliance with the License.
++   You may obtain a copy of the License at
++
++       http://www.apache.org/licenses/LICENSE-2.0
++
++   Unless required by applicable law or agreed to in writing, software
++   distributed under the License is distributed on an "AS IS" BASIS,
++   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++   See the License for the specific language governing permissions and
++   limitations under the License.
++*/
++#ifndef _GENE_H_
++#define _GENE_H_
++
++#include "neat.h"
++#include "trait.h"
++#include "network/network.h"
++
++namespace NEAT {
++
++    class InnovLinkGene {
++        real_t _weight; // Weight of connection
++        int _in_node_id; // NNode inputting into the link
++        int _out_node_id; // NNode that the link affects
++        bool _is_recurrent;
++        int _trait_id;  // identify the trait derived by this link
++
++    public:
++        inline int out_node_id() const { return _out_node_id; }
++        inline void set_out_node_id(int id) { _out_node_id = id; }
++
++        inline int in_node_id() const { return _in_node_id; }
++        inline void set_in_node_id(int id) { _in_node_id = id; }
++
++        inline real_t &weight() { return _weight; }
++
++        inline int trait_id() const { return _trait_id; }
++        inline void set_trait_id(int tid) { _trait_id = tid; }
++
++        inline bool is_recurrent() const { return _is_recurrent; }
++        inline void set_recurrent(bool r) { _is_recurrent = r; }
++
++
++        int innovation_num;
++        real_t mutation_num;  //Used to see how much mutation has changed the link
++        bool enable;  //When this is off the InnovLinkGene is disabled
++        bool frozen;  //When frozen, the linkweight cannot be mutated
++
++        // Construct a gene in an invalid default state.
++        InnovLinkGene() {}
++
++        //Construct a gene with no trait
++        InnovLinkGene(real_t w,
++                 int inode_id,
++                 int onode_id,
++                 bool recur,
++                 int innov,
++                 real_t mnum);
++
++        //Construct a gene with a trait
++        InnovLinkGene(int trait_id,
++                 real_t w,
++                 int inode_id,
++                 int onode_id,
++                 bool recur,
++                 int innov,
++                 real_t mnum);
++
++        //Construct a gene off of another gene as a duplicate
++        InnovLinkGene(InnovLinkGene *g,
++                 int trait_id,
++                 int inode_id,
++                 int onode_id);
++
++        //Construct a gene from a file spec given traits and nodes
++        InnovLinkGene(const char *argline);
++
++        // Copy Constructor
++        InnovLinkGene(const InnovLinkGene& gene);
++
++        ~InnovLinkGene();
++
++        //Print gene to a file- called from Genome
++        void print_to_file(std::ostream &outFile);
++    };
++
++} // namespace NEAT
++
++
++#endif
+diff --git a/cpp/brain/innovgenome/innovnodegene.cpp b/cpp/brain/innovgenome/innovnodegene.cpp
+new file mode 100644
+index 0000000..b71f5a1
+--- /dev/null
++++ b/cpp/brain/innovgenome/innovnodegene.cpp
+@@ -0,0 +1,48 @@
++/*
++  Copyright 2001 The University of Texas at Austin
++
++  Licensed under the Apache License, Version 2.0 (the "License");
++  you may not use this file except in compliance with the License.
++  You may obtain a copy of the License at
++
++  http://www.apache.org/licenses/LICENSE-2.0
++
++  Unless required by applicable law or agreed to in writing, software
++  distributed under the License is distributed on an "AS IS" BASIS,
++  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++  See the License for the specific language governing permissions and
++  limitations under the License.
++*/
++#include "innovnodegene.h"
++#include <sstream>
++using namespace NEAT;
++
++InnovNodeGene::InnovNodeGene(nodetype ntype,int nodeid) {
++    type=ntype; //NEURON or SENSOR type
++    node_id=nodeid;
++    frozen=false;
++    trait_id=1;
++}
++
++InnovNodeGene::InnovNodeGene (const char *argline) {
++    std::stringstream ss(argline);
++    int nodety, nodepl;
++    ss >> node_id >> trait_id >> nodety >> nodepl;
++    type = (nodetype)nodety;
++
++    if(trait_id == 0)
++        trait_id = 1;
++
++    // Get the Sensor Identifier and Parameter String
++    // mySensor = SensorRegistry::getSensor(id, param);
++    frozen=false;  //TODO: Maybe change
++}
++
++InnovNodeGene::~InnovNodeGene() {
++}
++
++void InnovNodeGene::print_to_file(std::ostream &outFile) {
++    outFile<<"node "<<node_id<<" ";
++    outFile<<trait_id<<" ";
++    outFile<<(int)type<<std::endl;
++}
+diff --git a/cpp/brain/innovgenome/innovnodegene.h b/cpp/brain/innovgenome/innovnodegene.h
+new file mode 100644
+index 0000000..7545c71
+--- /dev/null
++++ b/cpp/brain/innovgenome/innovnodegene.h
+@@ -0,0 +1,50 @@
++/*
++ Copyright 2001 The University of Texas at Austin
++
++   Licensed under the Apache License, Version 2.0 (the "License");
++   you may not use this file except in compliance with the License.
++   You may obtain a copy of the License at
++
++       http://www.apache.org/licenses/LICENSE-2.0
++
++   Unless required by applicable law or agreed to in writing, software
++   distributed under the License is distributed on an "AS IS" BASIS,
++   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++   See the License for the specific language governing permissions and
++   limitations under the License.
++*/
++#pragma once
++
++#include <assert.h>
++#include "neat.h"
++#include <iostream>
++
++namespace NEAT {
++
++    class InnovNodeGene {
++        int trait_id;  // identify the trait derived by this node
++    public:
++        bool frozen; // When frozen, cannot be mutated (meaning its trait pointer is fixed)
++        nodetype type;
++        int node_id;  // A node can be given an identification number for saving in files
++
++        // Construct InnovNodeGene with invalid state.
++        InnovNodeGene() {}
++        InnovNodeGene(nodetype ntype,int nodeid);
++        // Construct the node out of a file specification using given list of traits
++        InnovNodeGene (const char *argline);
++
++        ~InnovNodeGene();
++
++        inline void set_trait_id(int id) { assert(id > 0); trait_id = id; }
++        inline int get_trait_id() const {return trait_id;}
++
++        inline const nodetype get_type() const {return type;}
++        inline void set_type(nodetype t) {type = t;}
++
++        // Print the node to a file
++        void  print_to_file(std::ostream &outFile);
++    };
++
++} // namespace NEAT
++
+diff --git a/cpp/brain/innovgenome/innovnodelookup.h b/cpp/brain/innovgenome/innovnodelookup.h
+new file mode 100644
+index 0000000..c791918
+--- /dev/null
++++ b/cpp/brain/innovgenome/innovnodelookup.h
+@@ -0,0 +1,41 @@
++#pragma once
++
++#include "innovnodegene.h"
++#include <vector>
++#include <algorithm>
++
++namespace NEAT {
++
++    inline bool nodelist_cmp(const InnovNodeGene &a, const InnovNodeGene &b) {
++        return a.node_id < b.node_id;
++    }
++    inline bool nodelist_cmp_key(const InnovNodeGene &node, int node_id) {
++        return node.node_id < node_id;
++    }
++
++    class InnovNodeLookup {
++        std::vector<InnovNodeGene> &nodes;
++    public:
++        // Must be sorted by node_id in ascending order
++    InnovNodeLookup(std::vector<InnovNodeGene> &nodes_)
++        : nodes(nodes_) {
++        }
++
++        InnovNodeGene *find(int node_id) {
++            auto it = std::lower_bound(nodes.begin(), nodes.end(), node_id, nodelist_cmp_key);
++            if(it == nodes.end())
++                return nullptr;
++
++            InnovNodeGene &node = *it;
++            if(node.node_id != node_id)
++                return nullptr;
++
++            return &node;
++        }
++
++        InnovNodeGene *find(InnovNodeGene *n) {
++            return find(n->node_id);
++        }
++    };
++
++}
+diff --git a/cpp/brain/innovgenome/protoinnovlinkgene.h b/cpp/brain/innovgenome/protoinnovlinkgene.h
+new file mode 100644
+index 0000000..3c51129
+--- /dev/null
++++ b/cpp/brain/innovgenome/protoinnovlinkgene.h
+@@ -0,0 +1,37 @@
++#pragma once
++
++namespace NEAT {
++
++    class ProtoInnovLinkGene {
++        InnovGenome *_genome = nullptr;
++        //todo: does this have to be a InnovLinkGene* now?
++        InnovLinkGene *_gene = nullptr;
++        InnovNodeGene *_in = nullptr;
++        InnovNodeGene *_out = nullptr;
++    public:
++        void set_gene(InnovGenome *genome, InnovLinkGene *gene) {
++            _genome = genome;
++            _gene = gene;
++        }
++        InnovLinkGene *gene() {
++            return _gene;
++        }
++
++        void set_out(InnovNodeGene *out) {
++            _out = out;
++            _gene->set_out_node_id(out->node_id);
++        }
++        InnovNodeGene *out() {
++            return _out ? _out : _genome->get_node(_gene->out_node_id());
++        }
++
++        void set_in(InnovNodeGene *in) {
++            _in = in;
++            _gene->set_in_node_id(in->node_id);
++        }
++        InnovNodeGene *in() {
++            return _in ? _in : _genome->get_node(_gene->in_node_id());
++        }
++    };
++
++}
+diff --git a/cpp/brain/innovgenome/recurrencychecker.h b/cpp/brain/innovgenome/recurrencychecker.h
+new file mode 100644
+index 0000000..ded76b4
+--- /dev/null
++++ b/cpp/brain/innovgenome/recurrencychecker.h
+@@ -0,0 +1,101 @@
++#pragma once
++
++namespace NEAT {
++
++    class RecurrencyChecker {
++    private:
++        size_t nnodes;
++        InnovLinkGene **links;
++        size_t nlinks;
++
++        static bool cmp_sort(const InnovLinkGene *x, const InnovLinkGene *y) {
++            return x->out_node_id() < y->out_node_id();
++        }
++
++        static bool cmp_find(const InnovLinkGene *x, int node_id) {
++            return x->out_node_id() < node_id;
++        }
++
++        bool find(int node_id, InnovLinkGene ***curr) {
++            if(*curr == nullptr) {
++                auto it = std::lower_bound(links, links + nlinks, node_id, cmp_find);
++                if(it == links + nlinks) return false;
++                if((*it)->out_node_id() != node_id) return false;
++
++                *curr = it;
++                return true;
++            } else {
++                (*curr)++;
++                if(*curr >= (links + nlinks)) return false;
++                if((**curr)->out_node_id() != node_id) return false;
++                return true;
++            }
++        }
++
++        // This checks a POTENTIAL link between a potential in_node and potential out_node to see if it must be recurrent
++        bool is_recur(int in_id, int out_id, int &count, int thresh) {
++            ++count;  //Count the node as visited
++            if(count > thresh) {
++                return false;  //Short out the whole thing- loop detected
++            }
++
++            if (in_id==out_id) return true;
++            else {
++                InnovLinkGene **gene = nullptr;
++                while( find(in_id, &gene) ) {
++                    //But skip links that are already recurrent
++                    //(We want to check back through the forward flow of signals only
++                    if(!(*gene)->is_recurrent()) {
++                        if( is_recur((*gene)->in_node_id(), out_id, count, thresh) )
++                            return true;
++                    }
++                }
++                return false;
++            }
++        }
++
++    public:
++        RecurrencyChecker(size_t nnodes_,
++                          std::vector<InnovLinkGene> &genome_links,
++                          InnovLinkGene **buf_links) {
++            nnodes = nnodes_;
++            links = buf_links;
++
++            nlinks = 0;
++            for(size_t i = 0; i < genome_links.size(); i++) {
++                InnovLinkGene *g = &genome_links[i];
++                if(g->enable) {
++                    links[nlinks++] = g;
++                }
++            }
++            std::sort(links, links + nlinks, cmp_sort);
++        }
++
++        bool is_recur(int in_node_id, int out_node_id) {
++            //These are used to avoid getting stuck in an infinite loop checking
++            //for recursion
++            //Note that we check for recursion to control the frequency of
++            //adding recurrent links rather than to prevent any paricular
++            //kind of error
++            int thresh=nnodes*nnodes;
++            int count = 0;
++
++            if(is_recur(in_node_id, out_node_id, count, thresh)) {
++                return true;
++            }
++
++            //ADDED: CONSIDER connections out of outputs recurrent
++            //todo: this was fixed to use place instead of type,
++            //      but not clear if this logic is desirable. Shouldn't it
++            //      just be checking if the output node is OUTPUT?
++            /*
++              if (((in_node->place)==OUTPUT)||
++              ((out_node->place)==OUTPUT))
++              return true;
++            */
++            return false;
++        }
++
++    };
++
++}
+diff --git a/cpp/brain/innovgenome/trait.cpp b/cpp/brain/innovgenome/trait.cpp
+new file mode 100644
+index 0000000..8684bfe
+--- /dev/null
++++ b/cpp/brain/innovgenome/trait.cpp
+@@ -0,0 +1,103 @@
++/*
++ Copyright 2001 The University of Texas at Austin
++
++   Licensed under the Apache License, Version 2.0 (the "License");
++   you may not use this file except in compliance with the License.
++   You may obtain a copy of the License at
++
++       http://www.apache.org/licenses/LICENSE-2.0
++
++   Unless required by applicable law or agreed to in writing, software
++   distributed under the License is distributed on an "AS IS" BASIS,
++   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++   See the License for the specific language governing permissions and
++   limitations under the License.
++*/
++
++#include "trait.h"
++#include <sstream>
++
++using namespace NEAT;
++
++Trait::Trait () {
++    for (int count=0;count<NUM_TRAIT_PARAMS;count++)
++        params[count]=0;
++    trait_id=0;
++}
++
++Trait::Trait(int id,real_t p1,real_t p2,real_t p3,real_t p4,real_t p5,real_t p6,real_t p7,real_t p8,real_t p9) {
++    trait_id=id;
++    params[0]=p1;
++    params[1]=p2;
++    params[2]=p3;
++    params[3]=p4;
++    params[4]=p5;
++    params[5]=p6;
++    params[6]=p7;
++    params[7]=0;
++}
++
++Trait::Trait(const Trait& t) {
++    for(int count=0; count < NUM_TRAIT_PARAMS; count++)
++        params[count]=(t.params)[count];
++
++    trait_id = t.trait_id;
++}
++
++
++Trait::Trait(Trait *t) {
++    for(int count=0;count<NUM_TRAIT_PARAMS;count++)
++        params[count]=(t->params)[count];
++
++    trait_id=t->trait_id;
++}
++
++
++Trait::Trait(const char *argline) {
++
++    std::stringstream ss(argline);
++    //Read in trait id
++ //   std::string curword;
++    //char delimiters[] = " \n";
++    //int curwordnum = 0;
++
++    //strcpy(curword, env->getUnit(argline, curwordnum++, delimiters));
++
++//    trait_id = atoi(curword);
++    ss >> trait_id;
++
++    //std::cout << ss.str() << " trait_id: " << trait_id << std::endl;
++
++    //IS THE STOPPING CONDITION CORRECT?  ALERT
++    for(int count=0;count<NUM_TRAIT_PARAMS;count++) {
++        //strcpy(curword, env->getUnit(argline, curwordnum++, delimiters));
++        //params[count] = atof(curword);
++        ss >> params[count];
++        //iFile>>params[count];
++    }
++
++}
++
++Trait::Trait(const Trait &t1, const Trait &t2) {
++    trait_id = t1.trait_id;
++    for(int count=0; count < NUM_TRAIT_PARAMS; count++)
++        params[count] = (t1.params[count] + t2.params[count]) / 2.0;
++}
++
++void Trait::print_to_file(std::ostream &outFile) {
++  outFile<<"trait "<<trait_id<<" ";
++  for(int count=0;count<NUM_TRAIT_PARAMS;count++)
++    outFile<<params[count]<<" ";
++
++  outFile<<std::endl;
++}
++
++void Trait::mutate(rng_t &rng) {
++    for(int count=0;count<NUM_TRAIT_PARAMS;count++) {
++        if (rng.prob()>env->trait_param_mut_prob) {
++            params[count]+=(rng.posneg()*rng.prob())*env->trait_mutation_power;
++            if (params[count]<0) params[count]=0;
++            if (params[count]>1.0) params[count]=1.0;
++        }
++    }
++}
+diff --git a/cpp/brain/innovgenome/trait.h b/cpp/brain/innovgenome/trait.h
+new file mode 100644
+index 0000000..6f9d265
+--- /dev/null
++++ b/cpp/brain/innovgenome/trait.h
+@@ -0,0 +1,69 @@
++/*
++ Copyright 2001 The University of Texas at Austin
++
++   Licensed under the Apache License, Version 2.0 (the "License");
++   you may not use this file except in compliance with the License.
++   You may obtain a copy of the License at
++
++       http://www.apache.org/licenses/LICENSE-2.0
++
++   Unless required by applicable law or agreed to in writing, software
++   distributed under the License is distributed on an "AS IS" BASIS,
++   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++   See the License for the specific language governing permissions and
++   limitations under the License.
++*/
++#ifndef _TRAIT_H_
++#define _TRAIT_H_
++
++#include "neat.h"
++#include "util/rng.h"
++
++namespace NEAT {
++
++    const int NUM_TRAIT_PARAMS = 8;
++
++    // ------------------------------------------------------------------
++    // TRAIT: A Trait is a group of parameters that can be expressed
++    //        as a group more than one time.  Traits save a genetic
++    //        algorithm from having to search vast parameter landscapes
++    //        on every node.  Instead, each node can simply point to a trait
++    //        and those traits can evolve on their own
++    class Trait {
++
++        // ************ LEARNING PARAMETERS ***********
++        // The following parameters are for use in
++        //   neurons that learn through habituation,
++        //   sensitization, or Hebbian-type processes
++
++    public:
++        int trait_id; // Used in file saving and loading
++        real_t params[NUM_TRAIT_PARAMS]; // Keep traits in an array
++
++        Trait ();
++
++        Trait(int id,real_t p1,real_t p2,real_t p3,real_t p4,real_t p5,real_t p6,real_t p7,real_t p8,real_t p9);
++
++        // Copy Constructor
++        Trait(const Trait& t);
++
++        // Create a trait exactly like another trait
++        Trait(Trait *t);
++
++        // Special constructor off a file assume word "trait" has been read in
++        Trait(const char *argline);
++
++        // Special Constructor creates a new Trait which is the average of 2 existing traits passed in
++        Trait(const Trait &t1, const Trait &t2);
++
++        // Dump trait to a stream
++        void print_to_file(std::ostream &outFile);
++
++        // Perturb the trait parameters slightly
++        void mutate(rng_t &rng);
++
++    };
++
++} // namespace NEAT
++
++#endif
+diff --git a/cpp/brain/split_cpg/converting_split_brain.h b/cpp/brain/split_cpg/converting_split_brain.h
+index ae7126a..378f546 100644
+--- a/cpp/brain/split_cpg/converting_split_brain.h
++++ b/cpp/brain/split_cpg/converting_split_brain.h
+@@ -27,10 +27,12 @@ public:
+                         double t,
+                         double step) 
+     {
+-	if ((t - start_eval_time_) > evaluation_rate_ && generation_counter_ < max_evaluations_) {
++	if (start_eval_time_ == 0 || (t - start_eval_time_) > evaluation_rate_ && generation_counter_ < max_evaluations_) {
+ 	    double fitness = evaluator_->fitness();
+-	    std::cout << fitness << std::endl;
+-	    this->learner->reportFitness("test", convertForLearner_(this->controller->getGenome()), fitness);
++	    if(start_eval_time_ != 0) {
++		std::cout << fitness << std::endl;
++		this->learner->reportFitness("test", convertForLearner_(this->controller->getGenome()), fitness);
++	    }
+ 	    this->controller->setGenome(convertForController_(this->learner->getNewGenome("test")));
+ 	    start_eval_time_ = t;
+ 	    evaluator_->start();
+diff --git a/cpp/brain/split_cpg/spline_controller.h b/cpp/brain/split_cpg/spline_controller.h
+new file mode 100644
+index 0000000..478a799
+--- /dev/null
++++ b/cpp/brain/split_cpg/spline_controller.h
+@@ -0,0 +1,201 @@
++//
++// Created by Milan Jelisavcic on 28/03/16.
++//
++
++#ifndef REVOLVE_BRAIN_SPLINE_CONTROLLER_H
++#define REVOLVE_BRAIN_SPLINE_CONTROLLER_H
++
++#include "controller.h"
++
++#include <cmath>
++#include <string>
++
++
++namespace revolve {
++    namespace brain {
++
++//    typedef std::vector<double> Spline;
++//    typedef std::vector<Spline *> Policy;
++
++        class SplineController : public revolve::brain::Controller<std::vector<std::vector<double>>> {
++	protected:
++	    struct Config;
++        public:
++            typedef std::vector<double> Spline;
++            typedef std::vector<Spline> Policy;
++            typedef std::shared_ptr<Policy> PolicyPtr;
++            /**
++             * The RLPower constructor reads out configuration file, deretmines which algorithm type to apply and
++             * initialises new policy.
++             * @param modelName: name of a robot
++             * @param brain: configuration file
++             * @param evaluator: pointer to fitness evaluatior
++             * @param n_actuators: number of actuators
++             * @param n_sensors: number of sensors
++             * @return pointer to the RLPower class object
++             */
++            SplineController(std::string modelName,
++                    Config brain,
++                    EvaluatorPtr evaluator,
++                    unsigned int n_actuators,
++                    unsigned int n_sensors);
++
++            virtual ~SplineController();
++
++            /**
++             * Method for updating sensors readings, actuators positions, ranked list of policies and generating new policy
++             * @param actuators: vector list of robot's actuators
++             * @param sensors: vector list of robot's sensors
++             * @param t:
++             * @param step:
++             */
++            virtual void update(const std::vector<ActuatorPtr> &actuators,
++                                const std::vector<SensorPtr> &sensors,
++                                double t,
++                                double step);
++	    /**
++	    * Get method for the genome
++	    * @return current genome
++	    */
++	    virtual G getGenome();
++	    
++	    /**
++	    * Set method for the genome
++	    * @param newGenome: new genome to use instead of the old one
++	    */
++	    virtual void setGenome(G newGenome);
++      
++        protected:
++//        /**
++//         * Request handler to modify the neural network
++//         */
++//        void modify(ConstModifyNeuralNetworkPtr &req);
++//
++//        boost::mutex networkMutex_; // Mutex for stepping / updating the network
++
++            /**
++             * Ranked list of used splines
++             */
++            class PolicySave {
++            public:
++                PolicyPtr policy_;
++                double fitness_;
++
++                PolicySave(double fitness, PolicyPtr &p) :
++                        policy_(p),
++                        fitness_(fitness) {}
++
++                bool operator>(const PolicySave &ps) const {
++                    return this->fitness_ > ps.fitness_;
++                }
++            };
++
++            static const unsigned int MAX_EVALUATIONS;// = 1000; // max number of evaluations
++            static const unsigned int MAX_RANKED_POLICIES;// = 10; // max length of policies vector
++            static const unsigned int INTERPOLATION_CACHE_SIZE;// = 100; // number of data points for the interpolation cache
++            static const unsigned int INITIAL_SPLINE_SIZE;// = 3; // number of initially sampled spline points
++            static const unsigned int UPDATE_STEP;// = 100; // after # generations, it increases the number of spline points
++            static const double EVALUATION_RATE;// = 30.0; // evaluation time for each policy
++            static const double SIGMA_START_VALUE;// = 0.8; // starting value for sigma
++            static const double SIGMA_TAU_CORRECTION;// = 0.2;
++
++            static const double CYCLE_LENGTH;// = 5; // seconds
++            static const double SIGMA_DECAY_SQUARED;// = 0.98; // sigma decay
++
++            template<typename ActuatorContainer, typename SensorContainer>
++            void update(const ActuatorContainer &actuators,
++                        const SensorContainer &sensors,
++                        double t,
++                        double step) {
++
++                // generate outputs
++                double *output_vector = new double[n_actuators_];
++                this->generateOutput(t, output_vector);
++
++                // Send new signals to the actuators
++                unsigned int p = 0;
++                for (auto actuator: actuators) {
++                    actuator->update(&output_vector[p], step);
++                    p += actuator->outputs();
++                }
++
++                delete[] output_vector;
++            }
++
++            struct Config {
++                std::string algorithm_type;
++                unsigned int evaluation_rate;
++                unsigned int interpolation_spline_size;
++                unsigned int max_evaluations;
++                unsigned int max_ranked_policies;
++                double noise_sigma;
++                double sigma_tau_correction;
++                unsigned int source_y_size;
++                unsigned int update_step;
++                std::string policy_load_path;
++            };
++
++        private:
++
++            /**
++             * Generate cache policy
++             */
++            void generateCache();
++            /**
++             * Generate interpolated spline based on number of sampled control points in 'source_y'
++             * @param source_y: set of control points over which interpolation is generated
++             * @param destination_y: set of interpolated control points (default 100 points)
++             */
++            void interpolateCubic(Policy *const source_y,
++                                  Policy *destination_y);
++
++            /**
++             * Increment number of sampling points for policy
++             */
++            void increaseSplinePoints();
++
++            /**
++             * Randomly select two policies and return the one with higher fitness
++             * @return an iterator from 'ranked_policies_' map
++             */
++            std::map<double, RLPower::PolicyPtr>::iterator binarySelection();
++
++            /**
++             * Extracts the value of the current_policy in x=time using linear
++             * interpolation
++             *
++             * Writes the output in output_vector
++             */
++            void generateOutput(const double time,
++                                double *output_vector);
++
++            PolicyPtr current_policy_ = NULL; // Pointer to the current policy
++            PolicyPtr interpolation_cache_ = NULL; // Pointer to the interpolated current_policy_ (default 100 points)
++            EvaluatorPtr evaluator_ = NULL; // Pointer to the fitness evaluator
++
++            unsigned int generation_counter_; // Number of current generation
++            unsigned int interpolation_spline_size_; // Number of 'interpolation_cache_' sample points
++            unsigned int max_ranked_policies_; // Maximal number of stored ranked policies
++            unsigned int max_evaluations_; // Maximal number of evaluations
++            unsigned int n_actuators_; // Number of actuators
++            unsigned int n_sensors_; // Number of sensors
++            unsigned int source_y_size_; //
++            unsigned int step_rate_; //
++            unsigned int update_step_; // Number of evaluations after which sampling size increases
++
++            double cycle_start_time_;
++            double evaluation_rate_;
++            double noise_sigma_; // Noise in generatePolicy() function
++            double sigma_tau_correction_; // Tau deviation for self-adaptive sigma
++            double start_eval_time_;
++
++            std::string robot_name_; // Name of the robot
++            std::string algorithm_type_; // Type of the used algorithm
++            std::string policy_load_path_; // Load path for previously saved policies
++            std::map<double, PolicyPtr, std::greater<double>> ranked_policies_; // Container for best ranked policies
++        };
++
++    }
++}
++
++#endif //REVOLVE_BRAIN_SPLINE_CONTROLLER_H
+\ No newline at end of file
+diff --git a/cpp/neat/accneat/src/neattypes.h b/cpp/neat/accneat/src/neattypes.h
+index 116e89c..d76a84f 100644
+--- a/cpp/neat/accneat/src/neattypes.h
++++ b/cpp/neat/accneat/src/neattypes.h
+@@ -19,7 +19,10 @@ namespace NEAT {
+         NT_BIAS = 0,
+         NT_SENSOR = 1,
+         NT_OUTPUT = 2,
+-        NT_HIDDEN = 3
++        NT_HIDDEN = 3,
++	NT_SIMPLE = 4,
++	NT_SIGMOID = 5,
++	NT_DIFFERENTIAL_CPG = 6
+     };
+ 
+     struct OrganismEvaluation {
